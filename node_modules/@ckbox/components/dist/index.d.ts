/// <reference types="react" />
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 */
import * as React$1 from 'react';
import React__default, { useEffect } from 'react';
import { Placement } from '@popperjs/core';
import { TransitionProps } from 'react-transition-group/Transition';
import * as react_dnd from 'react-dnd';

declare const Bottombar: React$1.ForwardRefExoticComponent<Props$2t & React$1.RefAttributes<HTMLDivElement>>;
interface Props$2t {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Content rendered on the right side of the bar.
     */
    sideContent: React$1.ReactNode;
    /**
     * Content rendered as status summary in a absolute left-positioned container
     */
    statusContent?: React$1.ReactNode;
}

type ButtonSize = 'small' | 'medium' | 'large';
type ButtonType = 'fill' | 'outline' | 'plain' | 'link';
type ButtonColor = 'action' | 'danger' | 'neutral';

interface Props$2s {
    /**
     * Toggles optional icon animation.
     */
    animateIn?: boolean;
    /**
     * Sets root class name.
     */
    className: string;
    /**
     * Optional test ID.
     */
    'data-testid'?: string;
}

declare const AccessTime: React$1.FC<Props$2s>;

declare const Add: React$1.FC<Props$2s>;

declare const ArrowBackIosNewOutlined$1: React$1.FC<Props$2s>;

declare const ArrowBackIosNewOutlined: React$1.FC<Props$2s>;

declare const ArrowLeft: React$1.FC<Props$2s>;

declare const ArrowRight: React$1.FC<Props$2s>;

declare const ArticleOutlined: React$1.FC<Props$2s>;

declare const CaretRight: React$1.FC<Props$2s>;

declare const Check: React$1.FC<Props$2s>;

declare const CheckCircleOutline: React$1.FC<Props$2s>;

declare const ChevronDown: React$1.FC<Props$2s>;

declare const ChevronLeftOutlined: React$1.FC<Props$2s>;

declare const ChevronRightOutlined: React$1.FC<Props$2s>;

declare const Close: React$1.FC<Props$2s>;

declare const ContentCopyOutlined: React$1.FC<Props$2s>;

declare const CreateNewFolderOutlined: React$1.FC<Props$2s>;

declare const DeleteOutlineOutlined: React$1.FC<Props$2s>;

declare const DragHandle: React$1.FC<Props$2s>;

declare const DriveFileRenameOutlineOutlined: React$1.FC<Props$2s>;

declare const DriveFolderUploadOutlined: React$1.FC<Props$2s>;

declare const EditOutlined: React$1.FC<Props$2s>;

declare const FileCopyOutlined: React$1.FC<Props$2s>;

declare const FileMoveOutlined: React$1.FC<Props$2s>;

declare const FileDownloadOutlined: React$1.FC<Props$2s>;

declare const FileUploadOutlined: React$1.FC<Props$2s>;

declare const Filter: React$1.FC<Props$2s>;

declare const FirstPageOutlined: React$1.FC<Props$2s>;

declare const Folder: React$1.FC<Props$2s>;

declare const FolderOutlined: React$1.FC<Props$2s>;

declare const InfoOutlined: React$1.FC<Props$2s>;

declare const Inventory2Outlined: React$1.FC<Props$2s>;

declare const KeyboardDoubleArrowLeft: React$1.FC<Props$2s>;

declare const KeyboardDoubleArrowRight: React$1.FC<Props$2s>;

declare const LastPageOutlined: React$1.FC<Props$2s>;

declare const MoreVert: React$1.FC<Props$2s>;

declare const PhotoOutlined: React$1.FC<Props$2s>;

declare const SearchMissingResults: React$1.FC<Props$2s>;

declare const SearchOutlined: React$1.FC<Props$2s>;

declare const SettingsOutlined: React$1.FC<Props$2s>;

declare const Sort: React$1.FC<Props$2s>;

declare const Spinner: React$1.FC<Props$2s>;

declare const Tune: React$1.FC<Props$2s>;

declare const UploadFileOutlined: React$1.FC<Props$2s>;

declare const VisibilityOutlined: React$1.FC<Props$2s>;

declare const WarningAmber: React$1.FC<Props$2s>;

declare const WarningFill: React$1.FC<Props$2s>;

declare const XCircle: React$1.FC<Props$2s>;

declare const icons$1_AccessTime: typeof AccessTime;
declare const icons$1_Add: typeof Add;
declare const icons$1_ArrowLeft: typeof ArrowLeft;
declare const icons$1_ArrowRight: typeof ArrowRight;
declare const icons$1_ArticleOutlined: typeof ArticleOutlined;
declare const icons$1_CaretRight: typeof CaretRight;
declare const icons$1_Check: typeof Check;
declare const icons$1_CheckCircleOutline: typeof CheckCircleOutline;
declare const icons$1_ChevronDown: typeof ChevronDown;
declare const icons$1_ChevronLeftOutlined: typeof ChevronLeftOutlined;
declare const icons$1_ChevronRightOutlined: typeof ChevronRightOutlined;
declare const icons$1_Close: typeof Close;
declare const icons$1_ContentCopyOutlined: typeof ContentCopyOutlined;
declare const icons$1_CreateNewFolderOutlined: typeof CreateNewFolderOutlined;
declare const icons$1_DeleteOutlineOutlined: typeof DeleteOutlineOutlined;
declare const icons$1_DragHandle: typeof DragHandle;
declare const icons$1_DriveFileRenameOutlineOutlined: typeof DriveFileRenameOutlineOutlined;
declare const icons$1_DriveFolderUploadOutlined: typeof DriveFolderUploadOutlined;
declare const icons$1_EditOutlined: typeof EditOutlined;
declare const icons$1_FileCopyOutlined: typeof FileCopyOutlined;
declare const icons$1_FileDownloadOutlined: typeof FileDownloadOutlined;
declare const icons$1_FileMoveOutlined: typeof FileMoveOutlined;
declare const icons$1_FileUploadOutlined: typeof FileUploadOutlined;
declare const icons$1_Filter: typeof Filter;
declare const icons$1_FirstPageOutlined: typeof FirstPageOutlined;
declare const icons$1_Folder: typeof Folder;
declare const icons$1_FolderOutlined: typeof FolderOutlined;
declare const icons$1_InfoOutlined: typeof InfoOutlined;
declare const icons$1_Inventory2Outlined: typeof Inventory2Outlined;
declare const icons$1_KeyboardDoubleArrowLeft: typeof KeyboardDoubleArrowLeft;
declare const icons$1_KeyboardDoubleArrowRight: typeof KeyboardDoubleArrowRight;
declare const icons$1_LastPageOutlined: typeof LastPageOutlined;
declare const icons$1_MoreVert: typeof MoreVert;
declare const icons$1_PhotoOutlined: typeof PhotoOutlined;
declare const icons$1_SearchMissingResults: typeof SearchMissingResults;
declare const icons$1_SearchOutlined: typeof SearchOutlined;
declare const icons$1_SettingsOutlined: typeof SettingsOutlined;
declare const icons$1_Sort: typeof Sort;
declare const icons$1_Spinner: typeof Spinner;
declare const icons$1_Tune: typeof Tune;
declare const icons$1_UploadFileOutlined: typeof UploadFileOutlined;
declare const icons$1_VisibilityOutlined: typeof VisibilityOutlined;
declare const icons$1_WarningAmber: typeof WarningAmber;
declare const icons$1_WarningFill: typeof WarningFill;
declare const icons$1_XCircle: typeof XCircle;
declare namespace icons$1 {
  export {
    icons$1_AccessTime as AccessTime,
    icons$1_Add as Add,
    ArrowBackIosNewOutlined$1 as ArrowBackIosNewOutlined,
    ArrowBackIosNewOutlined as ArrowForwardIosOutlined,
    icons$1_ArrowLeft as ArrowLeft,
    icons$1_ArrowRight as ArrowRight,
    icons$1_ArticleOutlined as ArticleOutlined,
    icons$1_CaretRight as CaretRight,
    icons$1_Check as Check,
    icons$1_CheckCircleOutline as CheckCircleOutline,
    icons$1_ChevronDown as ChevronDown,
    icons$1_ChevronLeftOutlined as ChevronLeftOutlined,
    icons$1_ChevronRightOutlined as ChevronRightOutlined,
    icons$1_Close as Close,
    icons$1_ContentCopyOutlined as ContentCopyOutlined,
    icons$1_CreateNewFolderOutlined as CreateNewFolderOutlined,
    icons$1_DeleteOutlineOutlined as DeleteOutlineOutlined,
    icons$1_DragHandle as DragHandle,
    icons$1_DriveFileRenameOutlineOutlined as DriveFileRenameOutlineOutlined,
    icons$1_DriveFolderUploadOutlined as DriveFolderUploadOutlined,
    icons$1_EditOutlined as EditOutlined,
    icons$1_FileCopyOutlined as FileCopyOutlined,
    icons$1_FileDownloadOutlined as FileDownloadOutlined,
    icons$1_FileMoveOutlined as FileMoveOutlined,
    icons$1_FileUploadOutlined as FileUploadOutlined,
    icons$1_Filter as Filter,
    icons$1_FirstPageOutlined as FirstPageOutlined,
    icons$1_Folder as Folder,
    icons$1_FolderOutlined as FolderOutlined,
    icons$1_InfoOutlined as InfoOutlined,
    icons$1_Inventory2Outlined as Inventory2Outlined,
    icons$1_KeyboardDoubleArrowLeft as KeyboardDoubleArrowLeft,
    icons$1_KeyboardDoubleArrowRight as KeyboardDoubleArrowRight,
    icons$1_LastPageOutlined as LastPageOutlined,
    icons$1_MoreVert as MoreVert,
    icons$1_PhotoOutlined as PhotoOutlined,
    icons$1_SearchMissingResults as SearchMissingResults,
    icons$1_SearchOutlined as SearchOutlined,
    icons$1_SettingsOutlined as SettingsOutlined,
    icons$1_Sort as Sort,
    icons$1_Spinner as Spinner,
    icons$1_Tune as Tune,
    icons$1_UploadFileOutlined as UploadFileOutlined,
    icons$1_VisibilityOutlined as VisibilityOutlined,
    icons$1_WarningAmber as WarningAmber,
    icons$1_WarningFill as WarningFill,
    icons$1_XCircle as XCircle,
  };
}

type IconRenderer = (props: {
    className?: string;
}) => JSX.Element;
type IconRenderProp = string | IconRenderer;
type IconName = keyof typeof icons$1;
type IconSize = 'small' | 'base' | 'medium' | 'big' | 'bigger' | 'humongous';
type IconColor = 'accent' | 'disabled' | 'danger' | 'muted' | 'warning' | 'success';

declare const Icon: React$1.FC<Props$2r>;
interface Props$2r {
    /**
     * Toggles animation.
     */
    animateIn?: boolean;
    /**
     * Sets root class.
     */
    className?: string;
    /**
     * Icon color.
     */
    color?: IconColor;
    /**
     * Name of selected icon.
     */
    name?: IconName;
    /**
     * Renders custom icon.
     *
     * Pass either a React component or raw markup as string.
     * Passed string must be sanitized beforehand so that it's safe to use.
     */
    render?: IconRenderProp;
    /**
     * Icon size.
     */
    size?: IconSize;
}

declare const Button: React$1.ForwardRefExoticComponent<Props$2q & React$1.RefAttributes<HTMLButtonElement>>;
interface Props$2q {
    /**
     * Applies active styling.
     */
    active?: boolean;
    /**
     * Sets root class.
     */
    className?: string;
    /**
     * Sets color type. Use in combination with `type` to achieve desired styling.
     */
    color?: ButtonColor;
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
    /**
     * Displays as disabled.
     */
    disabled?: boolean;
    /**
     * Id of a form element this button is associated with.
     */
    form?: string;
    /**
     * Sets full-width mode.
     */
    fullWidth?: boolean;
    /**
     * Button's html type.
     */
    htmlType?: 'button' | 'reset' | 'submit';
    /**
     * Button's aria label.
     */
    label?: string;
    /**
     * Icon to show next to content.
     */
    icon?: IconName;
    /**
     * Render method for icon to be shown next to content.
     */
    iconRender?: IconRenderProp;
    /**
     * Allows to pass custom content.
     */
    content?: React$1.ReactNode;
    /**
     * Toggles icon animation.
     */
    iconAnimateIn?: boolean;
    /**
     * Icon placement.
     */
    iconPlacement?: 'left' | 'right';
    /**
     * Sets `click` event handler.
     */
    onClick?: React$1.MouseEventHandler;
    /**
     * Sets `mouseleave` event handler.
     */
    onMouseLeave?: React$1.MouseEventHandler;
    /**
     * Uses smaller horizontal paddings.
     */
    narrow?: boolean;
    /**
     * Allows to make text color transparent.
     */
    textColor?: 'default' | 'transparent';
    /**
     * Sets styling type. Use in combination with `color` to achieve desired styling.
     */
    type?: ButtonType;
    /**
     * Specifies tab index for the button.
     */
    tabIndex?: number;
    /**
     * Sets sizing of the button.
     */
    sizing?: ButtonSize;
    /**
     * Disables line wrapping for label text
     */
    disabledLabelWrapping?: boolean;
}

declare const ButtonGroup: React$1.FC<Props$2p>;
interface Props$2p {
    /**
     * Button components.
     */
    children: React$1.ReactNode;
}

declare const CircularLoader: React$1.ForwardRefExoticComponent<Props$2o & React$1.RefAttributes<HTMLButtonElement>>;
interface Props$2o {
    /**
     * Component's label.
     */
    label?: string;
    /**
     * Current value in %.
     */
    value: number;
    /**
     * Displays error icon.
     */
    error?: boolean;
    /**
     * Displays aborted icon.
     */
    aborted?: boolean;
    /**
     * Callback invoked upon click event.
     */
    onClick?: () => void;
}

declare const DialogNextTitle: React$1.ForwardRefExoticComponent<Props$2n & React$1.RefAttributes<HTMLDivElement>>;
interface Props$2n {
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
    /**
     * Sets root header class.
     */
    className?: string;
    /**
     * Optional subtitle of the component.
     */
    subtitle?: React$1.ReactNode;
    /**
     * Sets ID of dialog title element.
     */
    titleId?: string;
}

declare const DialogNextColumn: React$1.ForwardRefExoticComponent<Props$2m & React$1.RefAttributes<HTMLDivElement>>;
interface Props$2m {
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
    /**
     * Sets root header class.
     */
    className?: string;
}

declare const DialogNextContent: React$1.ForwardRefExoticComponent<Props$2l & React$1.RefAttributes<HTMLDivElement>>;
interface Props$2l {
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
    /**
     * Sets root header class.
     */
    className?: string;
    /**
     * Adds default horizontal spacing.
     */
    horizontalSpacing?: boolean;
    /**
     * Sets the dialog content ID.
     */
    id?: string;
}

declare const DialogNextFooter: React$1.ForwardRefExoticComponent<Props$2k & React$1.RefAttributes<HTMLDivElement>>;
interface Props$2k {
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
    /**
     * Sets root header class.
     */
    className?: string;
}

declare const DialogNextCloseButton: React$1.ForwardRefExoticComponent<Props$2j & React$1.RefAttributes<HTMLButtonElement>>;
interface Props$2j {
    /**
     * Close button's label.
     */
    closeLabel?: string;
    /**
     * Sets button class.
     */
    className?: string;
}

declare const DialogNextHeader: React$1.ForwardRefExoticComponent<Props$2i & React$1.RefAttributes<HTMLDivElement>>;
interface Props$2i {
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
    /**
     * Sets root header class.
     */
    className?: string;
}

declare const DialogNextSeparator: React$1.ForwardRefExoticComponent<Props$2h & React$1.RefAttributes<HTMLDivElement>>;
interface Props$2h {
    /**
     * Sets root header class.
     */
    className?: string;
}

declare const DialogNext: React$1.ForwardRefExoticComponent<Props$2g & React$1.RefAttributes<HTMLDivElement>>;
interface Props$2g {
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
    /**
     * Sets root dialog class.
     */
    className?: string;
    /**
     * Callback invoked when dialog is closed.
     */
    onClose?: () => void;
    /**
     * Opens dialog. Use in combination with `onClose`.
     */
    open?: boolean;
    /**
     * Sets the dialog label.
     */
    label?: string;
    /**
     * Sets the ID of label element.
     */
    labelledBy?: string;
    /**
     * Sets the ID of description element.
     */
    describedBy?: string;
    /**
     * Sets dialog width.
     */
    width?: 'sm' | 'md';
    /**
     * Marks dialog as an alert.
     */
    alert?: boolean;
}

declare const DialogActions: React$1.FC<Props$2f>;
interface Props$2f {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
}

declare const DialogColumn: React$1.ForwardRefExoticComponent<Props$2e & React$1.RefAttributes<HTMLDivElement>>;
interface Props$2e extends React$1.HTMLAttributes<HTMLDivElement> {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Allows its content to overflow.
     */
    overflow?: boolean;
}

declare const DialogFooter: React$1.FC<Props$2d>;
interface Props$2d {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Content placed on a right-side of the footer.
     */
    sideContent?: {
        label: React$1.ReactNode;
        error?: boolean;
        warning?: boolean;
        onClick?: () => void;
    }[];
}

declare const DialogHeader: React$1.FC<Props$2c>;
interface Props$2c {
    /**
     * Sets focus on close button on mount.
     */
    autofocus?: boolean;
    /**
     * Close button's label.
     */
    closeLabel?: string;
    /**
     * Sets ID of dialog header description element.
     */
    descriptionId?: string;
    /**
     * Dialog title.
     */
    title?: string;
    /**
     * Dialog header type.
     */
    type?: 'success' | 'error' | 'info';
}

declare const DialogProgressHeader: React$1.FC<Props$2b>;
interface Props$2b {
    /**
     * Sets focus on close button on mount.
     */
    autofocus?: boolean;
    /**
     * Close button's label.
     */
    closeLabel?: string;
    /**
     * Sets ID of dialog header description element.
     */
    descriptionId?: string;
    /**
     * Indicates that progress is ongoing.
     */
    inProgress?: boolean;
    /**
     * Progress value.
     */
    progressValue?: number;
    /**
     * Secondary title.
     */
    subTitle?: React$1.ReactNode;
    /**
     * Dialog title.
     */
    title?: string;
}

declare const DialogRow: React$1.FC<Props$2a>;
interface Props$2a extends React$1.HTMLAttributes<HTMLDivElement> {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
}

declare const DialogSection: React$1.FC<Props$29>;
interface Props$29 {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Removes top spacing.
     */
    collapse?: boolean;
    /**
     * Makes component full height of its container.
     */
    fullHeight?: boolean;
    /**
     * Sets dialog section height.
     */
    height?: 'md';
    /**
     * Turns on accent background color.
     */
    accent?: boolean;
    /**
     * Toggles content spacing.
     */
    spacing?: boolean;
    /**
     * Accepts ref.
     */
    ref?: React$1.Ref<HTMLDivElement>;
    /**
     * Shows content as an error.
     */
    error?: boolean;
    /**
     * Shows content as a header.
     */
    header?: boolean;
    /**
     * Sets the dialog section ID.
     */
    id?: string;
}

interface DialogRootProps {
    /**
     * Main content of the component.
     */
    children: React.ReactNode;
    /**
     * Sets dialog height.
     */
    height?: 'md' | 'lg';
    /**
     * Shows dialog as a modal.
     */
    modal?: boolean;
    /**
     * Marks dialog as an alert.
     */
    alert?: boolean;
    /**
     * Callback invoked when dialog is closed.
     */
    onClose?: () => void;
    /**
     * Callback invoked on `keydown` event.
     */
    onKeyDown?: React.KeyboardEventHandler<HTMLElement>;
    /**
     * Sets dialog width.
     */
    width?: 'sm' | 'md' | 'lg' | 'xl';
    /**
     * Sets the dialog label.
     */
    label?: string;
    /**
     * Sets the ID of label element.
     */
    labelledBy?: string;
    /**
     * Sets the ID of description element.
     */
    describedBy?: string;
}
interface DialogSwitchProps extends DialogRootProps {
    /**
     * Dialog's minimize / maximize action will be animated if set to `true`.
     * Dialogs in `modal` mode cannot be animated.
     */
    animated?: boolean;
    /**
     * Element associated with dialog's minimize / maximize action. Use in combination with `animated` prop.
     */
    animationAnchor?: HTMLElement | null;
    /**
     * Shows dialog as a modal.
     */
    modal?: boolean;
    /**
     * Callback invoked when dialog is closed.
     */
    onClose?: () => void;
    /**
     * Opens dialog. Use in combination with `onClose`.
     */
    open?: boolean;
}
interface DialogProps extends DialogSwitchProps {
    /**
     * Makes dialog draggable. Dialogs in `modal` mode cannot be draggable.
     */
    draggable?: boolean;
    /**
     * Callback invoked on dragging the dialog. Use in combination with `draggable`.
     */
    onDrag?: () => void;
}

/**
 * Entry component for the dialog.
 * Initializes selected dialog mode and optionally adds common options and draggability if needed.
 */
declare const Dialog: React$1.FC<Props$28>;
type Props$28 = DialogProps;

interface Props$27 {
    /**
     * Sets root class.
     */
    className: string;
}

declare const Zip: React$1.FC<Props$27>;

declare const Empty: React$1.FC<Props$27>;

declare const Excel: React$1.FC<Props$27>;

declare const Img: React$1.FC<Props$27>;

declare const Movie: React$1.FC<Props$27>;

declare const Music: React$1.FC<Props$27>;

declare const Pdf: React$1.FC<Props$27>;

declare const Ppt: React$1.FC<Props$27>;

declare const Txt: React$1.FC<Props$27>;

declare const Word: React$1.FC<Props$27>;

declare const icons_Empty: typeof Empty;
declare const icons_Excel: typeof Excel;
declare const icons_Img: typeof Img;
declare const icons_Movie: typeof Movie;
declare const icons_Music: typeof Music;
declare const icons_Pdf: typeof Pdf;
declare const icons_Ppt: typeof Ppt;
declare const icons_Txt: typeof Txt;
declare const icons_Word: typeof Word;
declare namespace icons {
  export {
    Zip as Archive,
    icons_Empty as Empty,
    icons_Excel as Excel,
    icons_Img as Img,
    icons_Movie as Movie,
    icons_Music as Music,
    icons_Pdf as Pdf,
    icons_Ppt as Ppt,
    icons_Txt as Txt,
    icons_Word as Word,
  };
}

declare const DocIcon: React$1.FC<Props$26>;
type DocIconName = keyof typeof icons;
interface Props$26 {
    /**
     * Name of selected icon.
     */
    name: DocIconName;
    /**
     * Flag indicating whether icon should have limited size.
     */
    limitSize?: boolean;
}

declare const GalleryFigure: React$1.ForwardRefExoticComponent<Props$25 & React$1.RefAttributes<HTMLElement>>;
interface Props$25 {
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
    /**
     * Figure caption.
     */
    caption: string;
    /**
     * Use `data-visible` attribute for testing purposes.
     */
    'data-visible'?: boolean;
}

declare const GalleryItem: React$1.ForwardRefExoticComponent<Props$24 & React$1.RefAttributes<HTMLDivElement>>;
interface Props$24 {
    /**
     * Sets item as active.
     */
    active?: boolean;
    /**
     * Sets item's ID.
     */
    id?: string;
    /**
     * Toggles loading.
     */
    loading?: boolean;
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
    /**
     * Item name.
     */
    name: string;
    /**
     * Label of the button for selecting action.
     */
    selectButtonLabel?: string;
    /**
     * Label of the button for deselecting action.
     */
    deselectButtonLabel?: string;
    /**
     * Sets `click` event handler.
     */
    onClick?: React$1.MouseEventHandler<HTMLDivElement>;
    /**
     * Sets `keydown` event handler.
     */
    onKeyDown?: React$1.KeyboardEventHandler<HTMLDivElement>;
    /**
     * Sets `mousedown` event handler.
     */
    onMouseDown?: React$1.MouseEventHandler<HTMLDivElement>;
    /**
     * Sets `dblclick` event handler.
     */
    onDoubleClick?: React$1.MouseEventHandler<HTMLDivElement>;
    /**
     * Sets `click` event handler for checkbox.
     */
    onCheckboxClick?: React$1.MouseEventHandler<HTMLButtonElement>;
}

declare const Gallery: React$1.FC<Props$23>;
interface Props$23 {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Callback invoked whenever number of columns changes.
     */
    onColumnCountChange?: (columnsCount: number) => void;
    /**
     * Controls element focusability.
     */
    tabIndex?: number;
    /**
     * Represents zoom value. Pass value in range 0 .. 1.
     */
    zoom?: number;
}

/**
 * Polymorphism for `ref` is tricky. Let's type it as `any` for now.
 */

declare const Input: React$1.ForwardRefExoticComponent<Omit<Props$22, "ref"> & React$1.RefAttributes<any>>;
interface Props$22 {
    /**
     * Input's class name.
     */
    className?: string;
    /**
     * Marks input as disabled.
     */
    disabled?: boolean;
    /**
     * Marks input as read-only.
     */
    readOnly?: boolean;
    /**
     * Unique input's id.
     */
    id: string;
    /**
     * Uses `textarea` instead of `input`.
     */
    multiline?: boolean;
    /**
     * Input's name to register.
     */
    name?: string;
    /**
     * Callback invoked when the blur event is fired.
     */
    onBlur?: (evt: React$1.ChangeEvent<any>) => void;
    /**
     * Callback invoked when the value is changed.
     */
    onChange?: (evt: React$1.ChangeEvent<any>) => void;
    /**
     * Callback invoked when the element receives focus.
     */
    onFocus?: (evt: React$1.ChangeEvent<any>) => void;
    /**
     * Callback invoked when the element is clicked.
     */
    onClick?: (evt: React$1.ChangeEvent<any>) => void;
    /**
     * Input's type.
     */
    type?: 'text' | 'number' | 'url' | 'email';
    /**
     * Input's placeholder text value.
     */
    placeholder?: string;
    /**
     * Input's value.
     */
    value?: string;
    /**
     * Input's ref object.
     */
    ref?: React$1.Ref<any>;
    /**
     * Sizing variant.
     */
    size?: 'base' | 'md';
    /**
     * Indicate error in input element.
     */
    error?: boolean;
    /**
     * Number input's min value.
     */
    min?: string | number;
    /**
     * Number input's max value.
     */
    max?: string | number;
    /**
     * Input's label.
     */
    label?: string;
    /**
     * Styling variant.
     */
    variant?: 'default' | 'underline';
}

declare const MenuItem: React$1.FC<Props$21>;
interface Props$21 {
    /**
     * Disables auto-close on click.
     */
    disableAutoClose?: boolean;
    /**
     * Displays as disabled.
     */
    disabled?: boolean;
    /**
     * Associated icon.
     */
    icon?: IconName;
    /**
     * Icon size.
     */
    iconSize?: IconSize;
    /**
     * Action label.
     */
    label: string;
    /**
     * Action invoked upon click.
     */
    onClick?: () => void;
}

declare const MenuSubSection: React$1.FC<Props$20>;
interface Props$20 {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Indicates how content and title should be aligned.
     */
    align?: 'column' | 'row';
    /**
     * Indicates how children should be aligned.
     */
    alignChildren?: 'column' | 'row';
    /**
     * Display title as label.
     */
    label?: boolean;
    /**
     * Sets `for` attribute if title is displayed as label.
     */
    labelFor?: string;
    /**
     * Title of the subsection.
     */
    title: string;
}

declare const MenuSection: React$1.FC<Props$1$>;
interface Props$1$ {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Adds bottom border.
     */
    borderBottom?: boolean;
    /**
     * Title of the section.
     */
    title: string;
}

interface PopperContext {
    /**
     * Forces synchronous popper position update.
     */
    forceUpdate?: () => void;
}
/**
 * Defines React context for `Popper` component.
 */
declare const PopperContext: React$1.Context<PopperContext>;
declare const usePopperCtx: () => PopperContext;

type PopperPlacement = Placement;
type PopperAnchorRef = HTMLElement | null | undefined;
type PopperOffsetValue = 'none' | 'xs' | 'sm' | 'md' | 'lg' | 'xl';
type PopperOffset = [PopperOffsetValue, PopperOffsetValue];

declare const PopperArrow: React__default.FC<Props$1_>;
interface Props$1_ {
    /**
     * Sets arrow size.
     */
    size?: 'sm' | 'md';
}

declare const Popper: React__default.ForwardRefExoticComponent<Props$1Z & React__default.RefAttributes<HTMLElement>>;
interface Props$1Z {
    /**
     * Anchor element. Popper will be mounted to this element.
     */
    anchorEl?: HTMLElement | null;
    /**
     * Popper content.
     */
    children: React__default.ReactNode;
    /**
     * Class name that will be applied to popper content-wrapper.
     */
    className?: string;
    /**
     * Disables popper auto-flip.
     */
    disableFlip?: boolean;
    /**
     * Popper placement.
     */
    placement?: PopperPlacement;
    /**
     * Displacement from its reference element.
     */
    offset?: PopperOffset;
    /**
     * Aria role.
     */
    role?: React__default.AriaRole;
    /**
     * Makes popper same width as its anchor.
     */
    sameWidth?: boolean;
    /**
     * Callback invoked on keydown event inside the popper.
     */
    onKeyDown?: React__default.KeyboardEventHandler;
}

declare const Menu: React$1.ForwardRefExoticComponent<Props$1Y & React$1.RefAttributes<HTMLDivElement>>;
interface Props$1Y {
    /**
     * Anchor element.
     */
    anchorEl?: HTMLElement | null;
    /**
     * Shows an arrow pointing to the anchor element.
     */
    arrow?: boolean;
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Offsets popper element.
     */
    offset?: PopperOffset;
    /**
     * Callback invoked when component is about to close.
     */
    onClose?: () => void;
    /**
     * Menu popper's placement.
     */
    placement?: PopperPlacement;
    /**
     * Makes menu same width as its anchor.
     */
    sameWidth?: boolean;
}

declare const ModalDialogActionContent: React$1.ForwardRefExoticComponent<Props$1X & React$1.RefAttributes<HTMLDivElement>>;
interface Props$1X {
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
}

declare const ModalDialogActionItem: React$1.ForwardRefExoticComponent<Props$1W & React$1.RefAttributes<HTMLLIElement>>;
interface Props$1W {
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
    /**
     * Callback invoked upon action click.
     */
    onClick?: () => void;
    /**
     * Marks action as disabled.
     */
    disabled?: boolean;
    /**
     * Marks action as in progress.
     */
    isLoading?: boolean;
}

declare const ModalDialogCallout: React$1.ForwardRefExoticComponent<Props$1V & React$1.RefAttributes<HTMLDivElement>>;
interface Props$1V {
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
    /**
     * Sets the dialog content ID.
     */
    id?: string;
    /**
     * Indicates callout type.
     */
    type: 'error' | 'warning';
}

declare const ModalDialogContent: React$1.ForwardRefExoticComponent<Props$1U & React$1.RefAttributes<HTMLDivElement>>;
interface Props$1U {
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
    /**
     * Sets the dialog content ID.
     */
    id?: string;
}

declare const ModalDialogContentColumn: React$1.ForwardRefExoticComponent<Props$1T & React$1.RefAttributes<HTMLDivElement>>;
interface Props$1T {
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
    /**
     * Sets the dialog content ID.
     */
    id?: string;
}

declare const ModalDialogList: React$1.ForwardRefExoticComponent<Props$1S & React$1.RefAttributes<HTMLDivElement>>;
interface Props$1S {
    /**
     * Sets the dialog content ID.
     */
    id?: string;
    /**
     * Adds list title.
     */
    title?: string;
    /**
     * List items
     */
    children: React$1.ReactNode;
}

declare const ModalDialogListItem: React$1.ForwardRefExoticComponent<Props$1R & React$1.RefAttributes<HTMLLIElement>>;
interface Props$1R {
    /**
     * Item to display in the list.
     */
    children: React$1.ReactNode;
}

declare const ModalDialogFooter: React$1.ForwardRefExoticComponent<Props$1Q & React$1.RefAttributes<HTMLDivElement>>;
interface Props$1Q {
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
    /**
     * Spaces out children components with space between them.
     */
    spaceBetween?: boolean;
}

declare const ModalDialogFooterAction: React$1.ForwardRefExoticComponent<Props$1P & React$1.RefAttributes<HTMLDivElement>>;
interface Props$1P {
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
}

declare const ModalDialogHeader: React$1.ForwardRefExoticComponent<Props$1O & React$1.RefAttributes<HTMLDivElement>>;
interface Props$1O {
    /**
     * Enables the top border accent.
     */
    accent?: boolean;
    /**
     * Close button's label.
     */
    closeLabel?: string;
    /**
     * Name of selected icon.
     */
    icon?: 'info' | 'success' | 'error' | 'warning' | React$1.ReactElement<Props$2r>;
    /**
     * Optional sub title of the modal.
     */
    subTitle?: React$1.ReactNode;
    /**
     * Title of the modal.
     */
    title: React$1.ReactNode;
    /**
     * Sets ID of dialog header title element.
     */
    titleId?: string;
}

declare const ModalDialog: React$1.ForwardRefExoticComponent<Props$1N & React$1.RefAttributes<HTMLDivElement>>;
interface Props$1N {
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
    /**
     * Sets root dialog class.
     */
    className?: string;
    /**
     * Callback invoked when dialog is closed.
     */
    onClose?: () => void;
    /**
     * Opens dialog. Use in combination with `onClose`.
     */
    open?: boolean;
    /**
     * Sets the dialog label.
     */
    label?: string;
    /**
     * Sets the ID of label element.
     */
    labelledBy?: string;
    /**
     * Sets the ID of description element.
     */
    describedBy?: string;
    /**
     * Indicates modal type.
     */
    type?: 'info' | 'success' | 'error' | 'warning';
    /**
     * Sets dialog width.
     */
    width?: 'sm' | 'md';
    /**
     * Marks dialog as an alert.
     */
    alert?: boolean;
}

/**
 * Width of the collapsed navbar.
 */
declare const NAVBAR_COLLAPSED_WIDTH = 58;
/**
 * Minimum width of navbar in non-collapsed mode.
 */
declare const NAVBAR_MIN_WIDTH = 200;
/**
 * Maximum width of navbar in non-collapsed mode.
 */
declare const NAVBAR_MAX_WIDTH = 400;
/**
 * Defines how far user must scroll left or right to trigger navbar mode change.
 */
declare const COLLAPSE_THRESHOLD = 40;
/**
 * Delay for the purposes of toggling navbar preview.
 */
declare const NAVBAR_PREVIEW_TIMEOUT = 250;
/**
 * Delay before showing loading spinner animation.
 */
declare const NAVBAR_LOADING_DELAY = 250;

declare const navbarContextInitProps: NavbarContext;
interface NavbarContext {
    /**
     * Indicates if navbar is in collapsed mode.
     */
    navbarCollapsed?: boolean;
    /**
     * Indicates if collapsed navbar is in preview mode.
     */
    navbarPreviewed?: boolean;
    /**
     * Callback invoked whenever navbar collapse mode is changed.
     */
    onNavbarCollapseChange: (collapsed: boolean) => void;
    /**
     * Callback invoked whenever navbar preview mode is changed.
     */
    onNavbarPreviewChange: (previewed: boolean) => void;
}
declare const NavbarContext: React$1.Context<NavbarContext>;
declare const useNavbarCtx: () => NavbarContext;

declare const NavbarItem: React$1.FC<Props$1M>;
interface Props$1M {
    /**
     * Applies active styling.
     */
    active?: boolean;
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
    /**
     * Indicates if item is collapsible.
     */
    collapsible?: boolean;
    /**
     * Indicates if item is collapsed.
     */
    collapsed?: boolean;
    /**
     * Label used by toggle button in expanded state.
     */
    collapseLabel?: string;
    /**
     * Applies compact spacing.
     */
    compact?: boolean;
    /**
     * Marks item as disabled.
     */
    disabled?: boolean;
    /**
     * Label used by toggle button in collapsed state.
     */
    expandLabel?: string;
    /**
     * Marks item as loading.
     */
    loading?: boolean;
    /**
     * Marks item as currently loading own details.
     */
    isLoadingDetails?: boolean;
    /**
     * Click handler.
     */
    onClick?: () => void;
    /**
     * Handler invoked on collapsing an item.
     */
    onCollapse?: () => void;
    /**
     * Handler invoked on expanding an item.
     */
    onExpand?: () => void;
    /**
     * Handler invoked on toggling an item.
     */
    onToggle?: () => void;
    /**
     * Handler invoked on deleting an item.
     */
    onDelete?: () => void;
}

declare const NavbarItemContainer: React$1.FC<Props$1L>;
interface Props$1L {
    /**
     * Marks container as active.
     */
    active?: boolean;
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
}

declare const NavbarItemContent: React$1.FC<Props$1K>;
interface Props$1K {
    /**
     * Adds enter / exit animation.
     */
    animate?: boolean;
    /**
     * Aligns navbar item content.
     */
    align?: 'start' | 'end';
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Hides component visually.
     */
    hidden?: boolean;
}

declare const NavbarItemLabel: React$1.FC<Props$1J>;
interface Props$1J {
    /**
     * Toggles icon animation if parent item is hovered.
     */
    animateIconOnItemHover?: boolean;
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Displayed icon.
     */
    icon?: React$1.ReactElement<Props$2r>;
}

declare const NavbarItemsGroup: React$1.FC<Props$1I>;
interface Props$1I {
    /**
     * Animates group on collapse.
     */
    animated?: boolean;
    /**
     * Toggles animation.
     */
    animateIn?: boolean;
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Nesting level. Starts at 1.
     */
    level?: number;
}

declare const NavbarLink: React$1.FC<Props$1H>;
interface Props$1H {
    /**
     * Renders link content.
     */
    children: React$1.ReactNode | (({ collapsed }: {
        collapsed?: boolean;
    }) => React$1.ReactNode);
    /**
     * The URL that the link points to.
     */
    href?: string;
}

declare const NavbarScrollableContent: React$1.FC<Props$1G>;
interface Props$1G {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
}

declare const NavbarSeparator: React$1.FC;

declare const NavbarToggleButton: React$1.FC<Props$1F>;
interface Props$1F {
    /**
     * Label shown when navbar will collapse.
     */
    closeLabel?: string;
    /**
     * Label shown when navbar will lock expanded state.
     */
    lockLabel?: string;
    /**
     * Label shown when navbar will expand or will be in preview mode.
     */
    openLabel?: string;
}

declare const Navbar: React$1.FC<Props$1E>;
interface Props$1E {
    /**
     * Labels navigation element.
     */
    ariaLabel?: string;
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
}

declare const Modal: React$1.FC<Props$1D>;
interface Props$1D {
    /**
     * Optional children.
     */
    children?: React$1.ReactNode;
    /**
     * Optional class to append.
     */
    className?: string;
    /**
     * Callback invoked upon clicking on the overlay.
     */
    onClick?: React$1.MouseEventHandler;
    /**
     * Increases stacking of the modal. Useful to force one of few open modals to be always on top.
     */
    onTop?: boolean;
    /**
     * Color variant.
     */
    variant?: 'transparent' | 'semi-transparent';
}

declare const PanelActions: React$1.FC<Props$1C>;
interface Props$1C {
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
}

declare const PanelColumn: React$1.FC<Props$1B>;
interface Props$1B {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
}

declare const PanelContent: React$1.ForwardRefExoticComponent<Props$1A & React$1.RefAttributes<HTMLDivElement>>;
interface Props$1A {
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
    /**
     * Optional panel content's class name in non-edit mode.
     */
    className?: string;
    /**
     * Component shown in edit mode. By default, regular input field is shown in edit mode.
     */
    editComponent?: React$1.ReactNode;
    /**
     * Optional header in non-edit mode.
     */
    header?: string;
}

declare const PanelContentProp: React$1.FC<Props$1z>;
interface Props$1z {
    /**
     * Property label.
     */
    label: string;
    /**
     * Property value.
     */
    value: string;
}

declare const PanelDragHandle: React$1.ForwardRefExoticComponent<React$1.RefAttributes<HTMLDivElement>>;

declare const PanelList: React$1.FC<Props$1y>;
interface Props$1y {
    /**
     * Main content.
     */
    children: React$1.ReactNode;
    /**
     * Optional toolbar rendered on top of the list.
     */
    toolbar?: React$1.ReactNode;
    /**
     * Toggles loading effect for the toolbar.
     */
    toolbarLoading?: boolean;
}

declare const PanelListDivider: React$1.FC<Props$1x>;
interface Props$1x {
    /**
     * Toggles component opacity.
     */
    opaque?: boolean;
}

declare const PanelSide: React$1.FC<Props$1w>;
interface Props$1w {
    /**
     * Icon to display.
     */
    icon?: IconName;
    /**
     * Renders custom icon.
     *
     * Pass either a React component or raw markup as string.
     * Passed string must be sanitized beforehand so that it's safe to use.
     */
    iconRender?: IconRenderProp;
}

declare const PanelSkeleton: React$1.FC<Props$1v>;
interface Props$1v {
    /**
     * Number of loading blocks.
     */
    blocks?: number;
    /**
     * Relative size of a loading block.
     */
    size?: 'sm' | 'md' | 'lg';
}

declare const PanelTitle: React$1.ForwardRefExoticComponent<Props$1u & React$1.RefAttributes<HTMLDivElement>>;
interface Props$1u extends Omit<Props$1A, 'children'> {
    /**
     * Panel's title.
     */
    title: string;
    /**
     * Panel's description.
     */
    description?: React$1.ReactNode;
}

interface ListDndItem {
    /**
     * Unique id of a dnd item.
     */
    id: string;
    /**
     * Indicates if an item can be dragged.
     */
    isDraggable?: boolean;
}
interface ListDndItemHookProps extends ListDndItem {
    /**
     * Drag handle element.
     */
    dragHandle?: HTMLElement | null;
    /**
     * Current index of a drag item.
     */
    index: number;
    /**
     * Item root element.
     */
    itemRoot?: HTMLElement | null;
}
type ListDndMoveItem = (dragIndex: number, hoverIndex: number) => void;
type ListDndSetDraggable = (id: string) => ListDndSetDraggablePartial;
type ListDndSetDraggablePartial = (isDraggable: boolean) => void;
type ListDndOnDragEnd = () => void;
/**
 * List of props that a child of `SortableListItem` receives.
 * This type is intended to be used by components that want to be aware that they are dragged.
 */
interface ListDndChildProps {
    /**
     * Indicates if an item is in preview mode.
     */
    isPreview?: boolean;
    /**
     * Indicates if an item is being dragged.
     */
    isDragging?: boolean;
    /**
     * Indicates if an item is draggable.
     */
    isDraggable?: boolean;
    /**
     * Drag handle setter. Use it to separate drag handle from a preview.
     */
    setDragHandle?: (el: HTMLElement | null) => void;
    /**
     * Sets root item.
     *
     * In some scenarios, drag handle might be located inside an item.
     * In such cases, item root.
     */
    setItemRoot?: (el: HTMLElement | null) => void;
    /**
     * Marks item as draggable / non-draggable.
     */
    setDraggable?: ListDndSetDraggablePartial;
}

/**
 * Top-level hook that manages list state.
 *
 * @param initItems initial list items
 * @returns list info
 */
declare const useListDnd: (initItems: ListDndItem[]) => {
    items: ListDndItem[];
    moveItem: ListDndMoveItem;
    setItems: React$1.Dispatch<React$1.SetStateAction<ListDndItem[]>>;
    setDraggable: ListDndSetDraggable;
};

declare const SortableDndListItem: React$1.FC<Props$1t>;
interface Props$1t {
    /**
     * Current item's index in a list.
     */
    index: number;
    /**
     * Item's id.
     */
    id: string;
    /**
     * Indicates if item is draggable.
     */
    isDraggable?: boolean;
    /**
     * Indicates if item is currently in preview mode.
     */
    isPreview?: boolean;
    /**
     * Accepts a single child.
     */
    children: React$1.ReactElement | null;
}

interface SortableDndListContextShape {
    /**
     * Callback that performs list reordering.
     */
    moveItem: ListDndMoveItem;
    /**
     * Marks item as draggable / non-draggable.
     */
    setDraggable: ListDndSetDraggable;
    /**
     * Item type. Same value must be provided for all list items.
     */
    type: string;
    /**
     * Optional callback invoked when drag is over.
     */
    onDragEnd?: ListDndOnDragEnd;
}

declare const SortableDndList: React$1.FC<Props$1s>;
interface Props$1s extends SortableDndListContextShape {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Container element to scroll while dragging.
     */
    scrollableContainer?: HTMLElement | null;
}

interface PanelContextShape extends Partial<ListDndChildProps> {
    /**
     * Toggles `edit` mode.
     */
    edit?: boolean;
}

declare const Panel: React$1.ForwardRefExoticComponent<Props$1r & React$1.RefAttributes<HTMLDivElement>>;
interface Props$1r extends PanelContextShape {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Toggles component opacity.
     */
    opaque?: boolean;
    /**
     * Toggles component's `elevated` mode.
     */
    elevated?: boolean;
}

declare const Pagination: React$1.FC<Props$1q>;
interface Props$1q {
    /**
     * Disables interaction with pagination.
     */
    disabled?: boolean;
    /**
     * Aria label for input element.
     */
    enterPageLabel: string;
    /**
     * Total number of pages.
     */
    totalPages: number;
    /**
     * Label indicating total number of pages.
     */
    totalPagesLabel: string;
    /**
     * Callback invoked when page is changed.
     */
    onPageChange: (page: number) => void;
    /**
     * Currently selected page.
     */
    page: number;
    /**
     * Label for the first page button.
     */
    firstPageLabel?: string;
    /**
     * Label for the last page button.
     */
    lastPageLabel?: string;
    /**
     * Label for the next page button.
     */
    nextPageLabel?: string;
    /**
     * Label for the previous page button.
     */
    prevPageLabel?: string;
}

declare const ProgressPanel: React$1.ForwardRefExoticComponent<Props$1p & React$1.RefAttributes<HTMLDivElement>>;
interface Props$1p {
    /**
     * Additional info rendered close to a title.
     */
    additionalInfo?: React$1.ReactNode;
    /**
     * Applies error styling.
     */
    error?: boolean;
    /**
     * Applies warning styling.
     */
    warning?: boolean;
    /**
     * Applies full progress styling.
     */
    completed?: boolean;
    /**
     * Help text displayed below the bar.
     */
    helpText?: React$1.ReactNode;
    /**
     * Unique identifier of a panel.
     */
    id: string;
    /**
     * Panel title.
     */
    title: string;
    /**
     * Current progress value in %.
     */
    value: number;
}

declare const PropertiesTableRow: React$1.FC<Props$1o>;
interface Props$1o {
    /**
     * Item's label.
     */
    label: string;
    /**
     * Item's value.
     */
    value: React$1.ReactNode;
}

declare const PropertiesTable: React$1.FC<Props$1n>;
interface Props$1n {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
}

declare const ResponsiveImageFit: React$1.FC<Props$1m>;
interface Props$1m {
    /**
     * Image alt text.
     */
    alt: string;
    /**
     * Turns on cover mode.
     */
    allowCover?: boolean;
    /**
     * Set of default image sources.
     */
    defaultSrcSet?: string;
    /**
     * Visually hides image.
     */
    hidden?: boolean;
    /**
     * Callback invoked when resource failed to load.
     */
    onError?: () => void;
    /**
     * Callback invoked when resource has been loaded.
     */
    onLoad?: () => void;
    /**
     * Mime type of the optional source.
     */
    optionalSrcMimeType?: string;
    /**
     * Set of optional image sources.
     */
    optionalSrcSet?: string;
    /**
     * Current `sizes` value based on container size.
     */
    sizes?: number;
}

declare const ResponsiveImageFallback: React$1.FC<Props$1l>;
interface Props$1l {
    /**
     * Indicates if cover is allowed for the image.
     */
    allowCover?: boolean;
    /**
     * Original image's blurhash. Blurhash will be decoded under the hood into base64.
     */
    blurHash?: string;
    /**
     * Container element.
     */
    containerEl?: HTMLElement | null;
    /**
     * Original image's height.
     */
    originalHeight?: number;
    /**
     * Original image's width.
     */
    originalWidth?: number;
    /**
     * Flag indicating if fallback should be displayed.
     */
    showFallback?: boolean;
}

declare const ResponsiveImageScalable: React$1.FC<Props$1k>;
interface Props$1k {
    /**
     * Image alt text.
     */
    alt: string;
    /**
     * Element that contains responsive image.
     */
    containerEl?: HTMLElement | null;
    /**
     * Set of default image sources.
     */
    defaultSrcSet?: string;
    /**
     * Visually hides image.
     */
    hidden?: boolean;
    /**
     * Callback invoked when resource failed to load.
     */
    onError?: () => void;
    /**
     * Callback invoked when resource has been loaded.
     */
    onLoad?: () => void;
    /**
     * Mime type of the optional source.
     */
    optionalSrcMimeType?: string;
    /**
     * Set of optional image sources.
     */
    optionalSrcSet?: string;
    /**
     * Original width of the image.
     */
    originalWidth?: number;
    /**
     * Original height of the image.
     */
    originalHeight?: number;
    /**
     * Current `sizes` value based on container size.
     */
    sizes?: number;
}

declare const ResponsiveImage: React$1.FC<Props$1j>;
interface Props$1j {
    /**
     * List of available breakpoints.
     */
    breakpoints?: number[];
    /**
     * Responsive image.
     */
    children: React$1.ReactNode;
    /**
     * Element that contains responsive image.
     */
    containerEl?: HTMLElement | null;
    /**
     * Maps breakpoint value to a flag indicating if it is possible to display thumbnail as a cover for that breakpoint.
     */
    cover?: Record<number, boolean>;
    /**
     * Optional loader to show when image loading is in progress.
     */
    loader?: React$1.ReactNode;
}

declare const Skeleton: React$1.FC<Props$1i>;
interface Props$1i {
    /**
     * Optional class name. It overrides class responsible for background color.
     */
    className?: string;
    /**
     * Specifies component height.
     */
    height?: string;
    /**
     * Specifies component width.
     */
    width?: string;
}

declare const SortButton: React$1.FC<Props$1h>;
interface Props$1h {
    /**
     * Button's aria label.
     */
    label?: string;
    /**
     * Tooltip displayed on hover.
     */
    tooltip: string;
    /**
     * Order indicated on button's icon.
     */
    order: 'asc' | 'desc';
    /**
     * Sets `click` event handler.
     */
    onClick?: () => void;
}

declare const SwitchView: React$1.FC<Props$1g>;
interface Props$1g {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * View id.
     */
    id?: string;
    /**
     * Use `fallback` type to show a fallback view if no other `SwitchView` is matched.
     */
    type?: 'default' | 'fallback';
}

declare const Switch: React$1.FC<Props$1f>;
interface Props$1f {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * View id to match.
     */
    match?: string;
}

declare const SwitchInput: React$1.FC<Props$1e>;
interface Props$1e {
    /**
     * Sets current input's value.
     */
    checked: boolean;
    /**
     * Underlying input's id.
     */
    id: string;
    /**
     * Underlying input's name.
     */
    name: string;
    /**
     * Callback invoked upon value's change.
     */
    onChange: (checked: boolean) => void;
}

declare const TagList: React$1.FC<Props$1d>;
interface Props$1d {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Optional root class name.
     */
    className?: string;
}

declare const TagLabel: React$1.FC<Props$1c>;
interface Props$1c {
    /**
     * Emphasizes tag content.
     */
    bold?: boolean;
    /**
     * Sets component's children.
     */
    children: React$1.ReactNode;
}

declare const Tag: React$1.ForwardRefExoticComponent<Props$1b & React$1.RefAttributes<HTMLDivElement>>;
interface Props$1b {
    /**
     * Sets component's children.
     */
    children?: React$1.ReactNode;
    /**
     * Disables focusability of any focusable element.
     */
    disableFocusability?: boolean;
    /**
     * Callback invoked upon clicking on remove icon.
     */
    onRemove?: React$1.MouseEventHandler;
    /**
     * Sets tag radius.
     */
    radius?: 'md' | 'lg' | 'xl';
    /**
     * Sets tag size.
     */
    size?: 'sm' | 'md';
    /**
     * Sets tag as removable.
     */
    removable?: boolean;
    /**
     * Label associated with remove button.
     */
    removeLabel?: string;
}

declare const TagInput: React$1.FC<Props$1a>;
interface Props$1a {
    /**
     * Input's class name.
     */
    className?: string;
    /**
     * Label displayed in the popup when hovering over copy button.
     */
    copyBtnLabel?: string;
    /**
     * Label displayed in the popup upon clicking on the copy button.
     */
    copyBtnLabelCopied?: string;
    /**
     * Input field id.
     */
    id: string;
    /**
     * Callback invoked when component gains focus.
     */
    onFocus?: () => void;
    /**
     * Callback invoked when component loses focus.
     */
    onBlur?: () => void;
    /**
     * Callback invoked when tags change.
     */
    onChange: (tags: string[]) => void;
    /**
     * Input placeholder.
     */
    placeholder?: string;
    /**
     * Indicate error in input element.
     */
    error?: boolean;
    /**
     * List of tags to render.
     */
    tags: {
        label: string;
        bold?: boolean;
        removeLabel?: string;
        title?: string;
    }[];
}

declare const Tab: React$1.FC<Props$19>;
interface Props$19 {
    /**
     * Main content.
     */
    children: React$1.ReactNode;
    /**
     * Tab id.
     */
    id: string;
    /**
     * Tab label.
     */
    label: string;
}

declare const Tabs: React$1.FC<Props$18>;
interface Props$18 {
    /**
     * Currently selected tab.
     */
    activeTab: string;
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Callback invoked upon selecting a tab.
     */
    onTabSelect?: (tab: string) => void;
}

declare const Tooltip: React$1.FC<Props$17>;
interface Props$17 {
    /**
     * Main content of the component.
     * It must be a single child that accepts `ref`.
     */
    children: React$1.ReactNode;
    /**
     * Delay before displaying the tooltip.
     */
    delay?: number;
    /**
     * Tooltip placement.
     */
    placement?: PopperPlacement;
    /**
     * Tooltip helper component or text.
     */
    title: React$1.ReactNode;
}

/**
 * `TopbarAction` component acts as a props carrier only.
 */
declare const TopbarAction: React$1.FC<Props$16>;
interface Props$16 {
    /**
     * Applies active styling.
     */
    active?: boolean;
    /**
     * Associated icon.
     */
    icon: IconName;
    /**
     * Icon size.
     */
    iconSize?: IconSize;
    /**
     * Action label.
     */
    label: string;
    /**
     * Indicates if loading is in progress.
     */
    loading?: boolean;
    /**
     * Displays as disabled.
     */
    disabled?: boolean;
    /**
     * Action invoked upon click.
     */
    onClick?: () => void;
    /**
     * Download action URL.
     */
    downloadUrl?: string;
}

declare const Topbar: React$1.FC<Props$15>;
interface Props$15 {
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
    /**
     * Content rendered on the right side of the bar.
     */
    sideContent?: React$1.ReactNode;
}

declare const CONTAINER_QUERY_BREAKPOINTS: {
    xs: number;
    sm: number;
    md: number;
    lg: number;
    xl: number;
};

declare const uiContextInitProps: {
    rootEl: null;
    animationDuration: {
        primary: number;
        secondary: number;
    };
    navbarCollapsed: boolean;
    onNavbarCollapseChange: () => void;
    onNavbarPreviewChange: () => void;
    onNavbarWidthChange: () => void;
};
interface UIContext {
    /**
     * Represents UI's root element.
     */
    rootEl: HTMLDivElement | null;
    /**
     * Holds info about animation duration (in ms).
     *
     * Note that these values are extracted from CSS variables.
     * Therefore, CSS variables act here as the single source of truth.
     */
    animationDuration: {
        primary: number;
        secondary: number;
    };
    /**
     * Indicates if navbar should be collapsed.
     */
    navbarCollapsed?: boolean;
    /**
     * Indicates if collapsed navbar is in preview mode.
     */
    navbarPreviewed?: boolean;
    /**
     * Initial navbar width.
     */
    navbarWidth?: number;
    /**
     * Callback invoked whenever navbar collapse mode is changed.
     */
    onNavbarCollapseChange: (collapsed: boolean) => void;
    /**
     * Callback invoked whenever navbar preview mode is changed.
     */
    onNavbarPreviewChange: (previewed: boolean) => void;
    /**
     * Callback invoked whenever navbar width changes.
     */
    onNavbarWidthChange: (width: number) => void;
}
/**
 * Defines React context for i18n and sets defaults.
 */
declare const UIContext: React$1.Context<UIContext>;
declare const useUIContext: () => UIContext;

/**
 * Checks if both lists of items contain same items (order irrelevant).
 *
 * @param items1 list of items
 * @param items2 list of items
 * @returns flag indicating if lists of items are identical
 */
declare const areItemsIdentical: (items1: string[], items2: string[]) => boolean;

/**
 * Generates base64-encoded image from its `blurhash` representation.
 *
 * @param hash blurhash representation of an image
 * @returns base64-encoded image
 */
declare const base64FromBlurHash: (hash?: string) => string;

/**
 * Given preferred value and optional edge values,
 * chooses the one that is most suitable:
 *
 * - min value if preferred value is below min
 * - max value if preferred value is above max
 * - preferred value otherwise
 *
 * @param val preferred value
 * @param min optional minimum value
 * @param max optional maximum value
 * @returns chosen value
 */
declare const clamp: (val: number, min?: number, max?: number) => number;

declare const copyToClipboard: (text: string) => Promise<void>;
declare const copyObjectToClipboard: (data: ClipboardItem) => Promise<void>;
declare const readObjectFromClipboard: () => Promise<ClipboardItems>;

/**
 * Filters off falsey values and concatenates list of classes.
 *
 * @param classes list of classes / falsey values
 * @returns classes
 */
declare const clsx: (...classes: (string | undefined | null | number | boolean)[]) => string;

/**
 * Values representing mouse button.
 *
 * https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button
 */
declare enum MouseEventButton {
    Main = 0,
    Auxiliary = 1,
    Secondary = 2,
    Fourth = 3,
    Fifth = 4
}

/**
 * Given time distance in s, formats it by rounding to nearest time unit in accordance with predefined buckets.
 *
 * @param t time left (in s)
 */
declare const formatTimeDistance: (t: number) => {
    h: number;
    m: number;
    s: number;
};

/**
 * Retrieves amount of pixels in a blob if it's an image.
 * If given blob is an invalid image, returns undefined.
 *
 * @param data blob data to measure
 * @returns amount of pixels
 */
declare const getPixelCountFromImageBlob: (data: Blob) => Promise<number | undefined>;

/**
 * Calculates standard deviation based on provided list of numbers.
 *
 * @param array list of numbers
 * @returns standard deviation
 */
declare const getStandardDeviation: (array: number[]) => number | undefined;

declare const getValidChildren: <ChildProps>(children: React$1.ReactNode) => React$1.ReactElement<ChildProps, string | React$1.JSXElementConstructor<any>>[];

/**
 * Shorthand for recommended use of hasOwnProperty (see https://eslint.org/docs/rules/no-prototype-builtins).
 *
 * @param object checked object
 * @param propertyKey property key to check
 */
declare const hasOwnProperty: (object: Record<string, unknown>, propertyKey: string) => boolean;

type KeyModifier = 'altKey' | 'ctrlKey' | 'metaKey' | 'shiftKey';
type KeyAction = (evt: KeyEventLike) => void;
interface KeyCombination {
    value: string;
    mod?: KeyModifier;
}
/**
 * `KeyboardEvent`-like interface that will allow to use generated handlers as React's synthetic event handlers.
 * Only a subset of event properties are used.
 */
type KeyEventLike = Pick<KeyboardEvent, 'altKey' | 'ctrlKey' | 'metaKey' | 'shiftKey' | 'code' | 'key' | 'preventDefault' | 'stopPropagation'>;
interface KeyProps {
    /**
     * Defines which code will invoke the `onKeyDown` callback.
     * `code.value` corresponds to `evt.code`.
     *
     * Provide either `code` or `key`.
     */
    code?: KeyCombination;
    /**
     * Defines which key will invoke the `onKeyDown` callback.
     * `key.value` corresponds to `evt.key`.
     *
     * Provide either `code` or `key`.
     */
    key?: KeyCombination;
    /**
     * Callback to invoke when proper key code is detected.
     */
    action?: KeyAction;
    /**
     * Determines if action should propagate event further.
     */
    propagate?: boolean;
}

/**
 * Checks if event matches a single key combination.
 *
 * @param evt keyboard event
 * @param currentValue event key or code value
 * @param combination key combination
 * @returns flag indicating if combination is matched
 */
declare const matchesCombination: (evt: KeyEventLike, currentValue: string, { value, mod }: KeyCombination) => boolean;
/**
 * Creates `keydown` event listener for configured key combination(s).
 *
 * @param props key props
 * @returns event listener
 */
declare const getKeyHandler: (props: KeyProps[] | KeyProps) => (evt: KeyEventLike) => void;

declare const noOp: () => void;

interface RInterval {
    clear: () => void;
}

/**
 * Allows to use `requestAnimationFrame` in a manner similar to `setInterval`.
 * It should be used for animations instead of `setTimeout` and `setInterval`.
 *
 * @param callback callback invoked within a fram
 * @param delay optional callback invocation delay
 * @returns interval utils
 */
declare const rInterval: (callback: () => void, delay?: number) => RInterval;

interface BatchUpdatePayload {
    /**
     * Id of an update group. Each update group is registered under the provided `id` as key.
     */
    id: string;
}
interface BatchUpdateBatch<Payload> {
    /**
     * Holds latest update for each update group.
     */
    data: Record<string, Payload>;
    /**
     * Total number of updates that happened during specified interval.
     */
    count: number;
}

/**
 * Batches updates and releases them in specified intervals.
 * Accumulates total number of updates that happened within a batch.
 *
 * This hook is useful for grouping high frequency updates into a single batch,
 * so that downstream updates do not happen too often.
 *
 * @param updateCb callback that receives current batch in specified intervals
 * @param batchUpdateInterval instructs how often batch is released
 * @returns actions and batch
 */
declare const useBatchUpdate: <Payload extends BatchUpdatePayload>(updateCb: (batch: BatchUpdateBatch<Payload>) => void, batchUpdateInterval: number) => {
    batch: React$1.MutableRefObject<BatchUpdateBatch<Payload>>;
    pushUpdate: (payload: Payload) => void;
};

/**
 * Hook that allows to detect click events within app root but outside specified element.
 *
 * @param container outer container
 * @param el element outside which clicks should be detected
 * @param ignoredEl optional element to ignore
 * @param onClick callback invoked if click outside registered elements was detected
 * @returns action for registering elements
 */
declare const useClickAway: (container?: HTMLElement | null, el?: HTMLElement | null, ignoredEl?: HTMLElement | null, onClick?: () => void) => void;

declare const useClipboard: () => {
    copied: boolean;
    onCopy: (txtContent: string) => Promise<void>;
    tryOnObjectCopy: (data: ClipboardItem) => Promise<boolean>;
    onObjectRead: () => Promise<ClipboardItems | undefined>;
};

/**
 * Hook that allows to detect keydown events within specified container.
 *
 * @param container outer container
 * @param onKeyDown callback invoked on container keydown
 */
declare const useContainerKeyDown: (container?: HTMLElement | null, onKeyDown?: ((evt: KeyEventLike) => void) | undefined) => void;

/**
 * Use this hook in order to defer unmount of a component.
 * It makes sure that component relying on this hook can be mounted for at least `waitFor` period.
 * This is useful to keep loader-like components mounted for a minimum time to avoid "flashing" effect.
 *
 * @param loading loading flag
 * @param waitFor indicates minimum mount time
 * @returns flag indicating if component relying on this hook should be kept mounted
 */
declare const useDeferredUnmount: (loading: boolean, waitFor?: number) => boolean;

/**
 * Allows to delay `shouldWait` flag by a value specified by `delay` option.
 *
 * @param shouldWait observed flag
 * @param delay delay time (in ms)
 * @returns flag indicating if `delay` time has passed and `shouldWait` is still `true`.
 */
declare const useDelay: (shouldWait: boolean, delay: number) => boolean;

interface Dimensions {
    width: number;
    height: number;
    top: number;
    left: number;
}
interface ResizeOptions {
    /**
     * Resize direction.
     */
    dir?: 'SE' | 'SW';
    /**
     * Minimum resize width.
     */
    minWidth?: number;
    /**
     * Callback invoked when resizing is done.
     */
    onResizeEnd?: (dimensions: Dimensions) => void;
}

/**
 * Manages element resize.
 *
 * @param opts resize options
 * @returns resize state and utils
 */
declare const useResize: (opts: ResizeOptions) => {
    onMouseDown: React$1.MouseEventHandler<HTMLElement> | undefined;
    setResizableEl: (el: HTMLElement | null) => void;
    isResizing: boolean | undefined;
};

type DragHandler = (diff: {
    /**
     * Dragged element.
     */
    draggableEl: HTMLElement;
    /**
     * Initial X offset of dragged element in relation to its closest positioned ancestor.
     */
    initOffsetX: number;
    /**
     * Initial Y offset of dragged element in relation to its closest positioned ancestor.
     */
    initOffsetY: number;
    /**
     * Initial offset width of dragged element.
     */
    initOffsetWidth: number;
    /**
     * Initial offset height of dragged element.
     */
    initOffsetHeight: number;
    /**
     * Pointer's X client offset.
     */
    clientOffsetX: number;
    /**
     * Pointer's Y client offset.
     */
    clientOffsetY: number;
    /**
     * Value of a vector representing pointer movement in X axis.
     */
    clientVX: number;
    /**
     * Value of a vector representing pointer movement in Y axis.
     */
    clientVY: number;
}) => void;
type DragDimensionsHandler = (dimensions: Dimensions) => void;
interface DraggableOptions {
    /**
     * Callback invoked on dragging. Passes most recent drag vectors.
     */
    onDrag?: DragHandler;
    /**
     * Callback invoked on drag end.
     */
    onDragEnd?: DragDimensionsHandler;
    /**
     * Callback invoked on drag start.
     */
    onDragStart?: React.MouseEventHandler<HTMLElement>;
}
interface DraggableState {
    /**
     * Dragged element.
     */
    draggableEl: HTMLElement | null;
    /**
     * Indicates if dragging is happening.
     */
    isDragging?: boolean;
    /**
     * Event handler that should be attached to drag handle.
     */
    onMouseDown?: React.MouseEventHandler<HTMLElement>;
    /**
     * Setter for element that will be dragged.
     */
    setDraggableEl: (el: HTMLElement | null) => void;
}

/**
 * Manages element dragging.
 *
 * @param opts dragging options
 * @returns dragging state and utils
 */
declare const useDraggable: (opts?: DraggableOptions) => DraggableState;

/**
 * Keeps info about mount state.
 *
 * This hook is useful when paired with async effects.
 * For instance, an effect might be in progress but its parent hook gets unmounted. In such case, it's advised to not update hook state.
 *
 * @returns callback that returns info about mount state
 */
declare const useIsMounted: () => () => boolean;

declare const useIsomorphicLayoutEffect: typeof useEffect;

interface ItemsOverflowOptions {
    /**
     * Total number of items.
     */
    items: number;
    /**
     * Margin added to items at each breakpoint. Provide a value to accommodate space for e.g. `more` button.
     */
    itemsMargin: number;
}

/**
 * Calculates number of items that are visible within a container.
 *
 * @param opts hook options
 * @returns items overflow state
 */
declare const useItemsOverflow: (opts: ItemsOverflowOptions) => {
    init: boolean;
    setContainer: React$1.Dispatch<React$1.SetStateAction<HTMLDivElement | null>>;
    visibleItems: number;
};

/**
 * Use this hook in order to invoke a callback once the specified time passes.
 *
 * The hook exposes actions for initializing and resetting the timeout.
 *
 * @param onTimeout callback invoked when time specified by `delay` passes
 * @param delay timeout (in ms)
 * @returns timeout actions
 */
declare const useResettableTimeout: (onTimeout: () => void, delay: number) => {
    initTimeout: () => void;
    removeTimeout: () => void;
    resetTimeout: () => void;
};

/**
 * Provided with a list of breakpoints, chooses a breakpoint value that is greater than or equal container's width.
 * Additionally, it chooses another breakpoint by taking device's pixel ratio into account.
 *
 * Container's size changes are observed via `ResizeObserver`. Observer's callback invocation is throttled.
 *
 * @param breakpoints list of possible image widths
 * @param containerEl container element
 * @param enabled toggles `ResizeObserver`
 * @returns state and ref setters
 */
declare const useResponsiveSizes: (breakpoints: number[], containerEl?: HTMLElement | null, enabled?: boolean) => {
    sizes: number | undefined;
    pixelAdjSizes: number | undefined;
};

/**
 * Detects visibility of an element inside a scrollable container.
 *
 * @param element element to observe
 * @param scrollableContainerEl scrollable container
 * @param enabled toggles observer
 * @returns hook state and methods
 */
declare const useElementVisibility: (element?: HTMLElement | null, scrollableContainerEl?: HTMLElement | null, enabled?: boolean) => {
    visible: boolean;
};

interface DropFile {
    /**
     * File object.
     */
    file: File;
    /**
     * Path to the file, relative to the folder in which drag and drop started.
     */
    relativePath: string;
}
interface UseFilesDropProps {
    /**
     * Callback invoked when files are dropped.
     */
    onDrop?: (files: DropFile[]) => void;
}

/**
 * Hook that allows to connect any container and make it a drop target for files.
 *
 * @param hook props
 * @returns hook state and methods
 */
declare const useFilesDrop: ({ onDrop }: UseFilesDropProps) => {
    drop: react_dnd.ConnectDropTarget;
    isActive: boolean;
};

type Selected = Set<string>;

/**
 * This hook is responsible for selecting cells in a 2-dimensional grid.
 *
 * @param initCells initial list of cell ids
 * @param initColumnCount initial number of columns in the grid
 * @returns state setters / state slices
 */
declare const useGridSelection: (initCells?: string[], initColumnCount?: number) => {
    deselectAll: () => void;
    isAnySelected: boolean;
    isSingleSelected: boolean;
    lastSelectedId: string | undefined;
    selectAll: () => void;
    selectDown: () => void;
    selectedIds: Selected;
    selectedSize: number;
    selectLeft: () => void;
    selectRange: (id: string) => void;
    selectRangeDown: () => void;
    selectRangeLeft: () => void;
    selectRangeRight: () => void;
    selectRangeUp: () => void;
    selectRight: () => void;
    selectSingle: (id: string) => void;
    selectSome: (ids: string[]) => void;
    selectUp: () => void;
    toggleSelection: (id: string) => void;
    updateCells: (ids: string[]) => void;
    updateColumnCount: (columnCount: number) => void;
};

/**
 * A helper hook for a building a simple state machine. Useful for togglable popper-based components such as menus.
 *
 * @param initValue initial value
 * @returns toggle actions
 */
declare const useToggle: (initValue?: boolean) => {
    value: boolean;
    toggle: () => void;
    on: () => void;
    off: () => void;
};

/**
 * Listens to container element's size changes and sets target's width and height accordingly.
 *
 * This hook is useful if `object-fit: scale-down` CSS rule cannot be used,
 * e.g. if image's placeholder has different size than the original image
 * but the placeholder must be still scaled to fit the size of the original image.
 *
 * @param originalWidth original image's width
 * @param originalHeight original image's height
 * @param containerEl container element
 * @param enabled toggles `ResizeObserver`
 * @returns ref setters
 */
declare const useScaleDown: (originalWidth?: number, originalHeight?: number, containerEl?: HTMLElement | null, enabled?: boolean) => {
    setTargetElement: React$1.Dispatch<React$1.SetStateAction<HTMLElement | null>>;
};

interface XYCoord {
    x: number;
    y: number;
}
interface ScrollCoordsConfig {
    /**
     * Specifies fraction of the container
     * that will be used as upper and lower scroll bounds
     * (scrolling can happen only within those bounds).
     */
    containerMargin?: number;
    /**
     * Represents a value by which scroll vector is multiplied.
     * Adjust the value to fine tune scrolling speed.
     */
    speedCoef?: number;
    /**
     * Specifies the number of pixels that vertical mouse movement
     * must exceed so that scroll can happen.
     */
    initThresh?: number;
}
type OnScrollHandler = (vStart: {
    startX: number;
    startY: number;
}, vCurrent: {
    currentX: number;
    currentY: number;
}) => void;
interface ScrollOptions {
    /**
     * Triggering `mousedown` events on elements with the provided selector
     * will not initialize scrolling.
     */
    ignoredSelector?: string;
    /**
     * Callback that is invoked in intervals if scrolling has been initialied.
     * The callback is invoked for every `tick` of scrolling interval.
     */
    onScroll?: OnScrollHandler;
    /**
     * Callback invoked upon scroll end.
     */
    onScrollEnd?: () => void;
    /**
     * Callback invoked upon scroll start.
     */
    onScrollStart?: () => void;
}

/**
 * Calculates scrolling vector based on initial client coords, current client coords, and scrolling options.
 *
 * @param container scrollable container
 * @param initOffset initial client offset (e.g. mouse coords)
 * @param currentOffset current client offset (e.g. mouse coords)
 * @param config config option
 * @returns scrolling vector
 */
declare const getScrollVectors: (container: HTMLElement, initOffset: XYCoord, currentOffset: XYCoord, config?: ScrollCoordsConfig) => number;

/**
 * Allows to scroll a container while performing actions within that container.
 *
 * Container scrolling is initiated by a `mousedown` event within that container.
 * Then, on `mousemove` the scrolling can be either accelerated or slowed down.
 *
 * Scrolling can happen only if mouse pointer is placed close to the upper or lower edge of the container.
 *
 * @param container scrollable container
 * @param opts scroll options
 * @returns scroll info
 */
declare const useScroll: (container?: HTMLElement | null, opts?: ScrollOptions) => {
    isScrolling: boolean;
};

/**
 * Allows to scroll a container while dragging an item.
 *
 * @param container scrollable container
 * @param type item type that will trigger scrolling
 */
declare const useScrollDnd: (container?: HTMLElement | null, type?: string) => void;

/**
 * Hook for downloading file using hidden anchor tag.
 *
 * @returns function for downloading file
 */
declare const useDownload: (root?: HTMLElement | null) => {
    downloadFile: (downloadUrl: string) => void;
};

/**
 * Defines validators that can be used to check various user inputs.
 * They are intended to be used downstream to build validation rules for HTML forms.
 *
 * Validators must conform to the convention used by `react-hook-form`: They must return either `boolean` or an error message.
 * For more info see `validate` option: https://react-hook-form.com/api/useform/register
 */
/**
 * Creates validation rule that checks if supplied `value` is non-empty.
 * Whitespaces are trimmed before the check.
 *
 * @param msg error message
 * @returns validator that returns `true` if check passes, error message otherwise
 */
declare const nonEmpty: (msg: string) => (value?: string) => string | true;
/**
 * Creates validation rule that checks if supplied `value` is present in `allowedValues`.
 *
 * @param msg error message
 * @param allowedValues list of allowed values
 * @returns validator that returns `true` if check passes, error message otherwise
 */
declare const isAllowed: <T>(msg: string, allowedValues: T[]) => (value?: T | undefined) => string | true;
/**
 * Creates validation rule that checks if supplied `value` string is present in `allowedValues`.
 * Makes comparison without taking letter case into account.
 *
 * @param msg error message
 * @param allowedValues list of allowed values
 * @returns validator that returns `true` if check passes, error message otherwise
 */
declare const isCaseInsensitiveStringAllowed: (msg: string, allowedValues: string[]) => (value?: string) => string | true;
/**
 * Creates validation rule that checks if supplied array has at least one item.
 *
 * @param msg error message
 * @returns validator that returns `true` if check passes, error message otherwise
 */
declare const nonEmptyArray: <T>(msg: string) => (value?: T[] | undefined) => string | true;
/**
 * Creates validation rule that checks if supplied array does not exceed `max` items.
 *
 * @param msg error message
 * @returns validator that returns `true` if check passes, error message otherwise
 */
declare const maxItems: <T>(msg: string, max: number) => (value?: T[] | undefined) => string | true;
/**
 * Creates validation rule that checks if supplied `value` is not already present within `existingValues`.
 *
 * @param msg error message
 * @param existingValues list of existing values
 * @returns validator that returns `true` if check passes, error message otherwise
 */
declare const unique: <T>(msg: string, existingValues: T[]) => (value?: T | undefined) => string | true;
/**
 * Creates validation rule that checks if supplied value contains a dot.
 *
 * @param msg error message
 * @returns validator that returns `true` if check passes, error message otherwise
 */
declare const nonDotValue: (msg: string) => (values?: string[]) => string | true;
/**
 * Creates validation rule that checks if string length in an array doesn't exceed max length.
 *
 * @param msg error message
 * @param maxLength maximum length of the string in the array
 * @returns validator that returns `true` if check passes, error message otherwise
 */
declare const maxLength: (msg: string, maxLength: number) => (values?: string[]) => string | true;

declare const validators_d_isAllowed: typeof isAllowed;
declare const validators_d_isCaseInsensitiveStringAllowed: typeof isCaseInsensitiveStringAllowed;
declare const validators_d_maxItems: typeof maxItems;
declare const validators_d_maxLength: typeof maxLength;
declare const validators_d_nonDotValue: typeof nonDotValue;
declare const validators_d_nonEmpty: typeof nonEmpty;
declare const validators_d_nonEmptyArray: typeof nonEmptyArray;
declare const validators_d_unique: typeof unique;
declare namespace validators_d {
  export {
    validators_d_isAllowed as isAllowed,
    validators_d_isCaseInsensitiveStringAllowed as isCaseInsensitiveStringAllowed,
    validators_d_maxItems as maxItems,
    validators_d_maxLength as maxLength,
    validators_d_nonDotValue as nonDotValue,
    validators_d_nonEmpty as nonEmpty,
    validators_d_nonEmptyArray as nonEmptyArray,
    validators_d_unique as unique,
  };
}

declare const ViewDialog: React$1.FC<Props$14>;
interface Props$14 {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Label of close button.
     */
    closeLabel?: string;
    /**
     * Initial height of dialog window.
     */
    height: number | string;
    /**
     * Initial offset from the left.
     */
    left?: number;
    /**
     * Minimum height (in px) of dialog window.
     */
    minHeight?: number;
    /**
     * Minimum width (in px) of dialog window.
     */
    minWidth?: number;
    /**
     * Callback invoked upon closing of dialog window.
     */
    onClose?: () => void;
    /**
     * Callback invoked whenever dialog dragging is completed.
     */
    onDragEnd?: (dimensions: Dimensions) => void;
    /**
     * Callback invoked whenever dialog resizing is completed.
     */
    onResizeEnd?: (dimensions: Dimensions) => void;
    /**
     * Toggles open state of dialog window.
     */
    open: boolean;
    /**
     * Label of resize button (SE direction).
     */
    resizeSELabel?: string;
    /**
     * Label of resize button (SW direction).
     */
    resizeSWLabel?: string;
    /**
     * Initial offset from the top.
     */
    top?: number;
    /**
     * Initial width of dialog window.
     */
    width: number | string;
    /**
     * Label of the root dialog element.
     */
    label?: string;
}

declare const UIProvider: React$1.FC<Props$13>;
interface Props$13 {
    /**
     * Main content.
     */
    children: React$1.ReactNode;
    /**
     * Initial navbar mode.
     */
    navbarCollapsed?: boolean;
    /**
     * Initial navbar width.
     */
    navbarWidth?: number;
    /**
     * Registers callback for `keydown` events.
     */
    onKeyDown?: React$1.KeyboardEventHandler;
    /**
     * Callback invoked whenever navbar mode changes.
     */
    onNavbarCollapseChange?: (collapsed: boolean) => void;
    /**
     * Callback invoked whenever navbar resize ends.
     */
    onNavbarWidthChange?: (width: number) => void;
    /**
     * Dialog mode options.
     */
    dialog?: Omit<Props$14, 'children'>;
    /**
     * Name of selected theme.
     */
    theme?: string;
    /**
     * Aria label to set on root element.
     */
    label?: string;
}

declare const View: React$1.FC<Props$12>;
interface Props$12 {
    /**
     * Sets component's children.
     */
    children?: React$1.ReactNode;
}

declare const ViewContent: React$1.ForwardRefExoticComponent<Props$11 & React$1.RefAttributes<HTMLDivElement>>;
interface Props$11 {
    /**
     * Sets component's children.
     */
    children?: React$1.ReactNode;
    /**
     * Indicates if compact mode should be used.
     */
    compact?: boolean;
    /**
     * Indicates if content's area is active.
     */
    active?: boolean;
    /**
     * Sets content `mousedown` event handler.
     */
    onMouseDown?: React$1.MouseEventHandler<HTMLDivElement>;
    /**
     * Sets content `keydown` event handler.
     */
    onKeyDown?: React$1.KeyboardEventHandler;
}

declare const ViewContentBar: React$1.FC<Props$10>;
interface Props$10 {
    /**
     * Sets component's children.
     */
    children?: React$1.ReactNode;
}

declare const ViewFooter: React$1.FC<Props$$>;
interface Props$$ {
    /**
     * Sets component's children.
     */
    children?: React$1.ReactNode;
}

declare const ViewHeader: React$1.FC<Props$_>;
interface Props$_ {
    /**
     * Sets component's children.
     */
    children?: React$1.ReactNode;
}

declare const ViewSideContent: React$1.FC<Props$Z>;
interface Props$Z {
    /**
     * Sets component's children.
     */
    children?: React$1.ReactNode;
}

declare const ViewContentWrapper: React$1.FC<Props$Y>;
interface Props$Y {
    /**
     * Sets component's children.
     */
    children?: React$1.ReactNode;
}

declare const ViewWrapper: React$1.FC<Props$X>;
interface Props$X {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Sets navbar.
     */
    navbar?: React$1.ReactNode;
}

declare const RangeSlider: React$1.FC<Props$W>;
type Props$W = {
    /**
     * Slider value.
     */
    value: number;
    /**
     * Slider on change callback.
     *
     * @param value new slider value
     */
    onChange(value: number): void;
    /**
     * Slider step.
     */
    step: number;
    /**
     * Slider minimum value.
     */
    min: number;
    /**
     * Slider maximum value.
     */
    max: number;
    /**
     * Slider text values.
     */
    textValues?: Record<string, string>;
    /**
     * Renders range slider values labels.
     */
    showLabels?: boolean;
};

declare const FormFeedback: React$1.FC<Props$V>;
type Props$V = {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Feedback error.
     */
    error?: boolean;
    /**
     * Feedback warning.
     */
    warning?: boolean;
};

declare const FormGroup: React$1.FC<Props$U>;
interface Props$U {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Makes component occupy 50% of available width.
     */
    halfWidth?: boolean;
}

declare const FormGroupColumn: React$1.FC<Props$T>;
interface Props$T {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
}

declare const FormGroupInfo: React$1.FC<Props$S>;
interface Props$S {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
}

declare const FormInputLabel: React$1.FC<Props$R>;
type Props$R = {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Input id.
     */
    htmlFor: string;
    /**
     * Input id.
     */
    hidden?: boolean;
};

declare const Form: React$1.ForwardRefExoticComponent<Props$Q & React$1.RefAttributes<HTMLFormElement>>;
type Props$Q = {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Form class.
     */
    className?: string;
    /**
     * Data attribute useful for testing.
     */
    'data-form-ready'?: boolean;
    /**
     * Form element's id.
     */
    id?: string;
    /**
     * Form submit callback.
     */
    onSubmit: React$1.FormEventHandler<HTMLFormElement>;
};

declare const EmptyViewLabel: React$1.FC<Props$P>;
interface Props$P {
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
    /**
     * Adds styling for muted label.
     */
    muted?: boolean;
}

declare const EmptyView: React$1.ForwardRefExoticComponent<Props$O & React$1.RefAttributes<HTMLDivElement>>;
interface Props$O {
    /**
     * Adds active styling.
     */
    active?: boolean;
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
    /**
     * Data attribute useful for testing.
     */
    'data-loaded'?: boolean;
    /**
     * Empty view icon.
     */
    icon: IconName;
    /**
     * Sets styling mode.
     */
    type?: 'dropzone' | 'default';
}

declare const Ellipsis: React$1.FC<Props$N>;
interface Props$N {
    /**
     * Items to display.
     */
    items: string[];
    /**
     * Maximum items to display before shortening.
     */
    maxVisibleItems?: number;
}

declare const FilePreviewActions: React$1.FC<Props$M>;
interface Props$M {
    /**
     * Label of the back button.
     */
    backBtnLabel: string;
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
    /**
     * Text displayed as title in the action bar.
     */
    title: string;
}

declare const FilePreviewColumn: React$1.FC<Props$L>;
interface Props$L {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
}

declare const FilePreviewContent: React$1.ForwardRefExoticComponent<Props$K & React$1.RefAttributes<HTMLDivElement>>;
interface Props$K {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
}

declare const FilePreviewHoverable: React$1.ForwardRefExoticComponent<Props$J & React$1.RefAttributes<HTMLDivElement>>;
interface Props$J {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
}

declare const FilePreviewNavButton: React$1.FC<Props$I>;
type Side = 'left' | 'right';
interface Props$I {
    /**
     * Disables button.
     */
    disabled?: boolean;
    /**
     * Button's aria label.
     */
    label: string;
    /**
     * Callback invoked on click.
     */
    onClick?: () => void;
    /**
     * Places button on the specified side of the `FilePreview`.
     */
    side?: Side;
    /**
     * Placement of the button tooltip.
     */
    tooltipPlacement?: PopperPlacement;
}

declare const FilePreviewTooltip: React$1.FC<Props$H>;
interface Props$H {
    /**
     * Main content of the tooltip.
     */
    children?: React$1.ReactNode;
}

declare const FilePreview: React$1.ForwardRefExoticComponent<Props$G & React$1.RefAttributes<HTMLDivElement>>;
interface Props$G {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Label of the dialog element.
     */
    label?: string;
    /**
     * Callback invoked when file preview is closed.
     */
    onClose?: () => void;
    /**
     * Callback invoked when next item is requested.
     */
    onNext?: () => void;
    /**
     * Callback invoked when previous item is requested.
     */
    onPrev?: () => void;
    /**
     * Opens file preview.
     */
    open?: boolean;
}

/**
 * Selection rectangle's coordinates.
 * All coordinates are in relation to container's top left corner.
 */
interface SelectionAreaCoords {
    /**
     * Selection rectangle's `x` position.
     */
    x: number;
    /**
     * Selection rectangle's `y` position.
     */
    y: number;
    /**
     * Selection rectangle's width.
     */
    width: number;
    /**
     * Selection rectangle's height.
     */
    height: number;
}

declare const SelectionArea: React$1.FC<Props$F>;
interface Props$F {
    /**
     * Selection area container.
     */
    container?: HTMLDivElement | null;
    /**
     * Area selection change handler.
     */
    onSelectionChange?: (area: SelectionAreaCoords) => void;
    /**
     * Selector for ignoring areas started within passed selector.
     */
    ignoredSelector?: string;
}

interface SelectOption {
    /**
     * Unique ID of an option.
     */
    id: string;
    /**
     * Value displayed for the user.
     */
    label: string;
}
interface SelectKeyboardNavProps {
    /**
     * Listbox element.
     */
    listboxEl: HTMLElement | null;
    /**
     * Flag indicating if listbox is currently open.
     */
    listboxOpen: boolean;
    /**
     * Callback that is called whenever listbox opening is requested.
     */
    onListboxOpen: () => void;
    /**
     * Toggles selection of an option.
     */
    onSelectToggle: SelectToggleHandler;
    /**
     * List of options to navigate.
     */
    options: SelectOption[];
    /**
     * Flag indicating if searchable select has text.
     */
    searchInProgress: boolean;
}
/**
 * Toggles selection of a provided option.
 */
type SelectToggleHandler = (opt: SelectOption) => void;
/**
 * Gets next / previous option (for keyboard selection).
 */
type SelectKeyboardNextIdGetter = (options: SelectOption[], currentIndex: number) => SelectOption | undefined;

declare const Select: React$1.FC<Props$E>;
interface Props$E {
    /**
     * Indicate error in input element.
     */
    error?: boolean;
    /**
     * ID of the input element.
     */
    id?: string;
    /**
     * Allows to select multiple options.
     */
    multiSelect?: boolean;
    /**
     * Callback invoked when component loses focus.
     */
    onBlur?: () => void;
    /**
     * Callback invoked whenever an item is selected or deselected.
     */
    onSelectToggle: SelectToggleHandler;
    /**
     * Message displayed if listbox is empty.
     */
    noOptionsLabel?: string;
    /**
     * List of options.
     */
    options: SelectOption[];
    /**
     * Textual placeholder if there are no options selected.
     */
    placeholder?: string;
    /**
     * List of selected options.
     */
    selected: SelectOption[];
    /**
     * Allows to search through options.
     */
    searchable?: boolean;
    /**
     * Sizing variant.
     */
    size?: 'small' | 'medium';
}

declare const Notifications: React$1.FC<Props$D>;
interface Props$D {
    /**
     * Container's position will be adjusted in accordance with provided element's height.
     */
    bottomOffsetEl?: HTMLElement | null;
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
}

type NotificationType = 'success' | 'error' | 'warning';

declare const Notification: React$1.FC<Props$C>;
/**
 * `Notification` component is rendered as part of `TransitionGroup` and therefore gets transition props in addition to its regular props.
 */
type Props$C = Partial<TransitionProps> & {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Label for "Close" button.
     */
    closeLabel: string;
    /**
     * Callback for close button.
     */
    onClose?: () => void;
    /**
     * Callback for details button.
     */
    onDetailsClick?: () => void;
    /**
     * Label for "Open Details" button.
     */
    openDetailsLabel?: string;
    /**
     * Notification type.
     */
    type: NotificationType;
};

declare const CopyableInput: React$1.FC<Props$B>;
interface Props$B {
    /**
     * Unique input's id.
     */
    id: string;
    /**
     * Input's value. This value will be copied to clipboard upon clicking on the copy button.
     */
    value?: string;
    /**
     * Input's class name.
     */
    className?: string;
    /**
     * Label displayed in the popup on hover and the internal button's aria-label.
     */
    labelCopy: string;
    /**
     * Label displayed in the popup upon clicking on the copy button.
     */
    labelCopied: string;
}

declare const CopyButton: React$1.FC<Props$A>;
interface Props$A {
    /**
     * Value to be copied to clipboard.
     */
    value?: string;
    /**
     * Label displayed in the popup on hover and the internal button's aria-label.
     */
    labelCopy: string;
    /**
     * Label displayed in the popup upon clicking on the copy button.
     */
    labelCopied: string;
}

type BreakpointKey = 'xs' | 'sm' | 'md' | 'lg' | 'xl';
type BreakpointMap = Record<BreakpointKey, number>;
/**
 * Encapsulates logic that allows to compare specified breakpoints.
 * Breakpoint values are treated as equivalent of CSS `min-width` property.
 * For instance, key `md` with value `900` means that breakpoint `md` is achieved for at least 900px of width.
 */
declare class Breakpoints {
    breakpoints: BreakpointMap;
    constructor(breakpoints: BreakpointMap);
    /**
     * Checks if requested key is lower than reference breakpoint.
     * Matches [0px, {key}) (`key` exclusive).
     *
     * @param key maximum requested breakpoint
     * @param breakpoint reference breakpoint
     * @returns flag indicating if requested key is lower than reference breakpoint
     */
    down(key: BreakpointKey, breakpoint: BreakpointKey): boolean;
    /**
     * Gets matching breakpoint key for the specified width.
     *
     * @param width width in px
     * @returns matching breakpoint key
     */
    toKey(width: number): BreakpointKey;
    /**
     * Checks if requested key is greater than or equal reference breakpoint.
     * Matches [{key}, ) (`key` inclusive).
     *
     * @param key minimum requested key
     * @param breakpoint reference breakpoint
     * @returns flag indicating if requested key is greater than or equal reference breakpoint
     */
    up(key: BreakpointKey, breakpoint: BreakpointKey): boolean;
}

interface ContainerQueryContext {
    /**
     * Current breakpoint key of the container.
     */
    key?: BreakpointKey;
    /**
     * Current vertical breakpoint key of the container.
     */
    keyVertical?: BreakpointKey;
    /**
     * Breakpoint utils.
     */
    breakpoints?: Breakpoints;
}
declare const ContainerQueryContext: React$1.Context<ContainerQueryContext>;
declare const useContainerQuery: () => ContainerQueryContext;

declare const ContainerQueryProvider: React$1.FC<Props$z>;
interface Props$z {
    /**
     * Maps breakpoint keys to width values. Each key corresponds to minimum value (in px).
     */
    breakpointValues: BreakpointMap;
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Element used as container.
     */
    containerEl?: HTMLElement | null;
}

declare const ContainerQuery: React$1.FC<Props$y>;
interface Props$y {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Specifies maximum breakpoint key at which component should be still shown.
     */
    down?: BreakpointKey;
    /**
     * Specifies minimum breakpoint key starting from which component should be shown.
     */
    up?: BreakpointKey;
}

interface FixedContext {
    /**
     * Element used a root for fixed UI components within the context.
     */
    rootEl?: HTMLElement | null;
}
declare const FixedContext: React$1.Context<FixedContext>;
declare const useFixedCtx: () => FixedContext;

declare const FixedProvider: React$1.FC<Props$x>;
interface Props$x {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * By default fixed components will be mounted at main UI root.
     * Provide a different element to use as a root.
     */
    rootEl?: HTMLElement | null;
}

declare const Fixed: React$1.FC<Props$w>;
interface Props$w {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
}

declare const LoadingButton: React$1.ForwardRefExoticComponent<Props$v & React$1.RefAttributes<HTMLButtonElement>>;
interface Props$v extends Props$2q {
    /**
     * Delays loader appearance. Defaults to `true`.
     */
    delay?: boolean;
    /**
     * Toggles loading state.
     */
    loading?: boolean;
    /**
     * Positions loader. Defaults to `center`.
     */
    loaderPosition?: 'left' | 'center' | 'right';
}

declare const ListItem: React$1.FC<Props$u>;
interface Props$u {
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
    /**
     * Callback invoked when clicking on list item content.
     */
    onClick?: () => void;
}

declare const ListItemActions: React$1.FC<Props$t>;
interface Props$t {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
}

declare const ListItemContent: React$1.FC<Props$s>;
interface Props$s {
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
    /**
     * Applied styling for muted variant.
     */
    muted?: boolean;
}

declare const List: React$1.FC<Props$r>;
interface Props$r {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * List's class name.
     */
    className?: string;
}

declare const SearchDialogActions: React$1.FC<Props$q>;
interface Props$q {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
}

declare const SearchDialogContent: React$1.FC<Props$p>;
interface Props$p {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
}

declare const SearchDialogFallback: React$1.FC<Props$o>;
interface Props$o {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
}

declare const SearchDialogHeader: React$1.FC<Props$n>;
interface Props$n {
    /**
     * Optional action rendered next to close button.
     */
    action?: React$1.ReactNode;
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Aria label for the close button.
     */
    closeBtnLabel: string;
    /**
     * Aria label for the input.
     */
    inputLabel: string;
    /**
     * Callback invoked when form is submitted.
     */
    onSubmit?: React$1.FormEventHandler;
}

declare const SearchDialogInput: React$1.ForwardRefExoticComponent<Props$m & React$1.RefAttributes<HTMLInputElement>>;
interface Props$m {
    /**
     * Input's name to register.
     */
    name?: string;
    /**
     * Callback invoked when the blur event is fired.
     */
    onBlur?: (evt: React$1.ChangeEvent) => void;
    /**
     * Callback invoked when the value is changed.
     */
    onChange?: (evt: React$1.ChangeEvent) => void;
    /**
     * Callback invoked when the element receives focus.
     */
    onFocus?: (evt: React$1.ChangeEvent) => void;
    /**
     * Input's placeholder text.
     */
    placeholder?: string;
    /**
     * Input's value.
     */
    value?: string;
}

declare const SearchDialogSection: React$1.FC<Props$l>;
interface Props$l {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Header of the section.
     */
    header?: string;
    /**
     * Side header buttons of the section
     */
    headerButtons?: React$1.ReactNode;
}

declare const SearchDialog: React$1.FC<Props$k>;
interface Props$k {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Label of the dialog element.
     */
    label?: string;
    /**
     * Callback invoked when dialog is closed.
     */
    onClose?: () => void;
    /**
     * Opens file preview.
     */
    open?: boolean;
}

declare const DrawerActions: React$1.FC<Props$j>;
interface Props$j {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
}

declare const DrawerContent: React$1.FC<Props$i>;
interface Props$i {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
}

declare const DrawerHeader: React$1.FC<Props$h>;
interface Props$h {
    /**
     * Text displayed as title in the bar.
     */
    title: string;
    /**
     * Label of the close button.
     */
    closeBtnLabel: string;
    /**
     * Name of selected icon.
     */
    iconName?: IconName;
    /**
     * Renders custom icon.
     */
    iconRender?: IconRenderProp;
}

declare const DrawerSection: React$1.ForwardRefExoticComponent<Props$g & React$1.RefAttributes<HTMLDivElement>>;
interface Props$g {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Fixes section's height.
     */
    fixedHeight?: boolean;
    /**
     * Centers section's content.
     */
    centeredContent?: boolean;
}

declare const Drawer: React$1.FC<Props$f>;
interface Props$f {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Label of the dialog element.
     */
    label?: string;
    /**
     * Callback invoked when drawer is closed.
     */
    onClose?: () => void;
    /**
     * Opens drawer.
     */
    open?: boolean;
    /**
     * Mounts drawer in a fixed mode. Defaults to `true`.
     */
    fixed?: boolean;
}

declare const SearchResultsBarPhrase: React$1.FC<Props$e>;
interface Props$e {
    /**
     * Sets the placeholder.
     */
    placeholder: React$1.ReactNode;
    /**
     * Sets the search results total count.
     */
    count: number;
}

declare const SearchResultsBarFilters: React$1.FC<Props$d>;
interface Props$d {
    /**
     * Sets component's children.
     */
    children: React$1.ReactNode;
}

declare const SearchResultsBar: React$1.FC<Props$c>;
interface Props$c {
    /**
     * Sets component's children.
     */
    children: React$1.ReactNode;
}

declare const TextEllipsis: React$1.FC<Props$b>;
interface Props$b {
    /**
     * Text content.
     */
    children: React$1.ReactNode;
    /**
     * Flag indicating if text should not wrap.
     */
    noWrap?: boolean;
}

declare const FileInput: React$1.ForwardRefExoticComponent<Props$a & React$1.RefAttributes<HTMLInputElement>>;
interface Props$a {
    /**
     * Specify comma-separated list of allowed file extensions.
     */
    accept?: string;
    /**
     * Allows to select directory instead of file.
     */
    directory?: boolean;
    /**
     * Allows to select multiple files.
     */
    multiple?: boolean;
    /**
     * Callback invoked when the value is changed.
     */
    onChange?: React$1.ChangeEventHandler<HTMLInputElement>;
}

declare const NavigationDialogContent: React$1.ForwardRefExoticComponent<Props$9 & React$1.RefAttributes<HTMLDivElement>>;
interface Props$9 {
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
}

declare const NavigationDialogFallbackContent: React$1.ForwardRefExoticComponent<Props$8 & React$1.RefAttributes<HTMLDivElement>>;
interface Props$8 {
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
}

declare const NavigationDialogFooter: React$1.ForwardRefExoticComponent<Props$7 & React$1.RefAttributes<HTMLDivElement>>;
interface Props$7 {
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
    /**
     * Sets root header class.
     */
    className?: string;
}

declare const NavigationDialogHeader: React$1.ForwardRefExoticComponent<Props$6 & React$1.RefAttributes<HTMLDivElement>>;
interface Props$6 {
    /**
     * Optional action component rendered next to title.
     */
    action?: React$1.ReactNode;
    /**
     * Main content of the header.
     */
    children: React$1.ReactNode;
    /**
     * Close button's label.
     */
    closeLabel?: string;
    /**
     * Indicates if title should be emphasized.
     */
    emphasized?: boolean;
    /**
     * Sets ID of dialog header title element.
     */
    titleId?: string;
}

declare const NavigationDialogItem: React$1.ForwardRefExoticComponent<Props$5 & React$1.RefAttributes<HTMLLIElement>>;
interface Props$5 {
    /**
     * Indicates if navbar item is active.
     */
    active?: boolean;
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
    /**
     * Indicates if navbar item is disabled.
     */
    disabled?: boolean;
    /**
     * Callback invoked upon button click.
     */
    onClick?: () => void;
    /**
     * Callback invoked upon button click.
     */
    onDoubleClick?: () => void;
}

declare const NavigationDialogItemAction: React$1.FC<Props$4>;
interface Props$4 {
    /**
     * Optional button.
     */
    button?: React$1.ReactElement<Props$2q> | null;
    /**
     * Optional icon.
     */
    icon?: React$1.ReactElement<Props$2r> | ((props: Props$2r) => React$1.ReactNode) | null;
}

declare const NavigationDialogItemLabel: React$1.FC<Props$3>;
interface Props$3 {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Displayed icon.
     */
    icon?: React$1.ReactElement<Props$2r>;
}

declare const NavigationDialog: React$1.ForwardRefExoticComponent<Props$2 & React$1.RefAttributes<HTMLDivElement>>;
interface Props$2 {
    /**
     * Main content of the component.
     */
    children?: React$1.ReactNode;
    /**
     * Sets the ID of description element.
     */
    describedBy?: string;
    /**
     * Sets the dialog label.
     */
    label?: string;
    /**
     * Sets the ID of label element.
     */
    labelledBy?: string;
    /**
     * Callback invoked when dialog is closed.
     */
    onClose?: () => void;
    /**
     * Opens dialog. Use in combination with `onClose`.
     */
    open?: boolean;
}

declare const CheckboxLabel: React$1.ForwardRefExoticComponent<Props$1 & React$1.RefAttributes<HTMLLabelElement>>;
interface Props$1 {
    /**
     * Main content of the component.
     */
    children: React$1.ReactNode;
    /**
     * Sets `for` attribute.
     */
    labelFor?: string;
}

declare const Checkbox: React$1.FC<Props>;
interface Props {
    /**
     * Optional content of the component.
     */
    children?: React$1.ReactNode;
    /**
     * Sets current input's value.
     */
    checked: boolean;
    /**
     * Disables focusability of input element.
     */
    disableFocusability?: boolean;
    /**
     * Underlying input's id.
     */
    id?: string;
    /**
     * Aria label of the input element.
     */
    label?: string;
    /**
     * Underlying input's name.
     */
    name?: string;
    /**
     * Callback invoked upon click.
     */
    onClick?: (evt: React$1.MouseEvent) => void;
    /**
     * Callback invoked upon value's change.
     */
    onChange: (checked: boolean) => void;
    /**
     * Marks checkbox as disabled.
     */
    disabled?: boolean;
}

export { Bottombar, Button, ButtonColor, ButtonGroup, ButtonSize, ButtonType, COLLAPSE_THRESHOLD, CONTAINER_QUERY_BREAKPOINTS, Checkbox, CheckboxLabel, CircularLoader, ContainerQuery, ContainerQueryProvider, CopyButton, CopyableInput, Dialog, DialogActions, DialogColumn, DialogFooter, DialogHeader, DialogNext, DialogNextCloseButton, DialogNextColumn, DialogNextContent, DialogNextFooter, DialogNextHeader, DialogNextSeparator, DialogNextTitle, DialogProgressHeader, DialogRow, DialogSection, Dimensions, DocIcon, DocIconName, DragDimensionsHandler, DragHandler, DraggableOptions, DraggableState, Drawer, DrawerActions, DrawerContent, DrawerHeader, DrawerSection, Ellipsis, EmptyView, EmptyViewLabel, FileInput, FilePreview, FilePreviewActions, FilePreviewColumn, FilePreviewContent, FilePreviewHoverable, FilePreviewNavButton, FilePreviewTooltip, Fixed, FixedContext, FixedProvider, Form, FormFeedback, FormGroup, FormGroupColumn, FormGroupInfo, FormInputLabel, Gallery, GalleryFigure, GalleryItem, Icon, IconColor, IconName, IconRenderProp, IconRenderer, IconSize, Input, Props$22 as InputProps, KeyAction, KeyCombination, KeyEventLike, KeyModifier, KeyProps, List, ListDndChildProps, ListDndItem, ListDndItemHookProps, ListDndMoveItem, ListDndOnDragEnd, ListDndSetDraggable, ListDndSetDraggablePartial, ListItem, ListItemActions, ListItemContent, LoadingButton, Menu, MenuItem, MenuSection, MenuSubSection, ModalDialog, ModalDialogActionContent, ModalDialogActionItem, ModalDialogCallout, ModalDialogContent, ModalDialogContentColumn, ModalDialogFooter, ModalDialogFooterAction, ModalDialogHeader, ModalDialogList, ModalDialogListItem, MouseEventButton, NAVBAR_COLLAPSED_WIDTH, NAVBAR_LOADING_DELAY, NAVBAR_MAX_WIDTH, NAVBAR_MIN_WIDTH, NAVBAR_PREVIEW_TIMEOUT, Navbar, NavbarContext, NavbarItem, NavbarItemContainer, NavbarItemContent, NavbarItemLabel, NavbarItemsGroup, NavbarLink, NavbarScrollableContent, NavbarSeparator, NavbarToggleButton, NavigationDialog, NavigationDialogContent, NavigationDialogFallbackContent, NavigationDialogFooter, NavigationDialogHeader, NavigationDialogItem, NavigationDialogItemAction, NavigationDialogItemLabel, Notification, Notifications, OnScrollHandler, Modal as Overlay, Pagination, Panel, PanelActions, PanelColumn, PanelContent, PanelContentProp, PanelDragHandle, PanelList, PanelListDivider, PanelSide, PanelSkeleton, PanelTitle, Popper, PopperAnchorRef, PopperArrow, PopperContext, PopperOffset, PopperOffsetValue, PopperPlacement, ProgressPanel, PropertiesTable, PropertiesTableRow, Props$2r as Props, RInterval, RangeSlider, ResizeOptions, ResponsiveImage, ResponsiveImageFallback, ResponsiveImageFit, ResponsiveImageScalable, ScrollCoordsConfig, ScrollOptions, SearchDialog, SearchDialogActions, SearchDialogContent, SearchDialogFallback, SearchDialogHeader, SearchDialogInput, SearchDialogSection, SearchResultsBar, SearchResultsBarFilters, SearchResultsBarPhrase, Select, SelectKeyboardNavProps, SelectKeyboardNextIdGetter, SelectOption, SelectToggleHandler, SelectionArea, SelectionAreaCoords, Skeleton, SortButton, SortableDndList, SortableDndListItem, Switch, SwitchInput, SwitchView, Tab, Tabs, Tag, TagInput, TagLabel, TagList, TextEllipsis, Tooltip, Topbar, TopbarAction, UIContext, UIProvider, Props$13 as UIProviderProps, View, ViewContent, ViewContentBar, ViewContentWrapper, ViewDialog, Props$14 as ViewDialogProps, ViewFooter, ViewHeader, ViewSideContent, ViewWrapper, XYCoord, areItemsIdentical, base64FromBlurHash, clamp, clsx, copyObjectToClipboard, copyToClipboard, formatTimeDistance, getKeyHandler, getPixelCountFromImageBlob, getScrollVectors, getStandardDeviation, getValidChildren, hasOwnProperty, matchesCombination, navbarContextInitProps, noOp, rInterval, readObjectFromClipboard, uiContextInitProps, useBatchUpdate, useClickAway, useClipboard, useContainerKeyDown, useContainerQuery, useDeferredUnmount, useDelay, useDownload, useDraggable, useElementVisibility, useFilesDrop, useFixedCtx, useGridSelection, useIsMounted, useIsomorphicLayoutEffect, useItemsOverflow, useListDnd, useNavbarCtx, usePopperCtx, useResettableTimeout, useResize, useResponsiveSizes, useScaleDown, useScroll, useScrollDnd, useToggle, useUIContext, validators_d as validators };
